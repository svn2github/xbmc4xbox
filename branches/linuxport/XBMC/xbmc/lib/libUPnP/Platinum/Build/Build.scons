import sys
import os
import os.path
import shutil
import imp
from glob import glob

#######################################################
# reusable functions and data structures
#######################################################
def LoadTool(name, env, **kw):
    config_path = GetBuildPath('#/Build/Tools/SCons')
    file, path, desc = imp.find_module(name, [config_path])
    module = imp.load_module(name, file, path, desc)
    module.generate(env, **kw)
    
def MergeListUnique(item_list, items):
    for item in items: 
        if not item in item_list: item_list.append(item)

def MergeItemUnique(item_list, item):
    if not item in item_list: item_list.append(item)

def GlobSources(drct, patterns, excluded_files=[]):
    root = GetBuildPath('#'+drct)
    files = []
    for pattern in Split(patterns):
        files += glob(root+'/'+pattern)
    return [drct+'/'+os.path.basename(x) for x in  files if os.path.basename(x) not in excluded_files]

def GetDirPath(dir):
    return '#/'+dir
    
def DeclareBuildDir(dir):
    env.BuildDir(dir, GetDirPath(dir), duplicate=0)
    
def GetIncludeDirs(modules, exclude=None):
    dirs = []
    for module in Split(modules):
        if Modules.has_key(module) and not module == exclude:
            MergeListUnique(dirs, Modules[module].GetIncludeDirs())
        else:
            MergeItemUnique(dirs, GetDirPath(module))
    return dirs
    
def GetLibraries(modules):
    libs = []
    for module in Split(modules):
        if module in libs: continue
        if Modules.has_key(module):
            dep_libs = Modules[module].GetLibraries()
            libs = [lib for lib in libs if not lib in dep_libs]+dep_libs
        else:
            libs.append(module)
    return libs

def BuildApp(name, 
             deps, 
             build_deps         = [], 
             source_dirs        = [], 
             build_include_dirs = [], 
             source_files       = [], 
             linked_modules     = [],
             source_root        = 'Source', 
             environment        = None, 
             extra_cpp_defines  = {}):
    # for each source drct to build, create a BuildDir
    # to say where we want the object files to be built,
    # and compute the list of source files to build
    sources = []
    for drct in Split(source_dirs):
        DeclareBuildDir(drct)
        sources += GlobSources(drct, ['*c', '*.cpp'])
        
    # add cherry-picked files
    for pair in source_files:
        drct = pair[0]
        pattern = pair[1]
        drct_path = source_root+'/'+drct
        DeclareBuildDir(drct_path)
        sources += GlobSources(drct_path, pattern)
        
    # check that the source list is not empty
    if len(sources) == 0:
        print "\n\n\tWARNING: application " + name + " does not have any source file\n\n"
        return 

    # calculate our build include path
    cpp_path = GetIncludeDirs(Split(build_include_dirs) + Split(source_dirs) + Split(deps))

    # libraries    
    libs = GetLibraries(Split(linked_modules))
    libs += GetLibraries(deps)

    # use the relevant environment    
    local_env = None
    if environment is not None:
        local_env = environment.Copy()
    else:
        local_env = env.Copy()
    local_env.Append(CPPDEFINES=extra_cpp_defines)
    local_env.AppendUnique(CPPDEFINES=local_env['PLT_GLOBAL_CPP_DEFINES'])

    # build
    prog = local_env.Program(target=name,
                             source=sources,
                             LIBS=libs, 
                             CPPPATH=cpp_path)
    # extra dependencies
    local_env.Depends(name, build_deps)
    
    # copy to Targets folder
    inst = local_env.Install (dir=env.GetBuildPath('#/Targets/'+env['target']+'/'+env['build_config']), source=prog)
    if env['build_config'] == 'Release':
        local_env.AddPostAction (inst, env.Action ('strip $TARGET'))
    else:
        local_env.AddPostAction (inst, env.Action (''))
    

Modules = {}
class Module:
    def __init__(self, name, included_modules = [], linked_modules = []):
        self.name             = name
        self.included_modules = included_modules
        self.linked_modules   = linked_modules
        self.product          = []

    def GetLibraries(self):
        return self.product+GetLibraries(self.linked_modules)
        
    def GetIncludeDirs(self):
        return GetIncludeDirs(self.included_modules+self.build_include_dirs, self.name)
    
class LibraryModule(Module):
    def __init__(self, name, 
                 build_source_dirs     = ['.'], 
                 build_source_files    = {},
                 source_root           = 'Source',
                 build_source_pattern  = ['*.c', '*.cpp'], 
                 build_include_dirs    = [], 
                 included_modules      = [], 
                 included_only_modules = [],
                 linked_modules        = [],
                 environment           = None,
                 excluded_files        = [],
                 extra_cpp_defines     = {},
                 shared                = False) :
        build_source_dirs = [source_root+'/'+drct for drct in build_source_dirs]
        Module.__init__(self, 
                        name, 
                        Split(included_modules)+Split(included_only_modules)+Split(build_source_dirs), 
                        Split(linked_modules)+Split(included_modules))
        self.build_include_dirs = build_include_dirs
        if environment is None:
            self.env            = env.Copy()
        else:
            self.env            = environment.Copy()
        self.env.Append(CPPDEFINES = extra_cpp_defines)
        
        # store this new object in the module dictionary
        Modules[name] = self
                
        # for each source drct to build, create a BuildDir
        # to say where we want the object files to be built,
        # and compute the list of source files to build
        sources = []
        for drct in Split(build_source_dirs):
            DeclareBuildDir(drct)
            sources += GlobSources(drct, build_source_pattern, excluded_files)
            
        # add cherry-picked files
        for drct in build_source_files.keys():
            pattern = build_source_files[drct]
            drct_path = source_root+'/'+drct
            DeclareBuildDir(drct_path)
            sources += GlobSources(drct_path, pattern)

        # calculate our build include path
        cpp_path = GetIncludeDirs(Split(self.build_include_dirs) + Split(build_source_dirs) + self.included_modules + self.linked_modules)

        # the product is a library
        self.env.AppendUnique(CPPDEFINES=self.env['PLT_GLOBAL_CPP_DEFINES'])
        self.env.AppendUnique(CPPPATH=cpp_path)
        if shared is False:
            self.product = self.env.Library(target=name, source=sources)
        else:
            libs = GetLibraries(Split(linked_modules))
            self.product = self.env.SharedLibrary(target=name, LIBS=libs, source=sources)
        self.env.Alias(name, self.product)
    
#######################################################
# Main Build
#######################################################
Import("env")

### defaults
env['NPT_EXTRA_LIBS'] = ''
env['PLT_EXTRA_LIBS'] = ''

if env['build_config'] == 'Debug':
	env['PLT_GLOBAL_CPP_DEFINES'] = {'NPT_CONFIG_ENABLE_LOGGING':None}
else:
	env['PLT_GLOBAL_CPP_DEFINES'] = {}

### try to read in any target specific configuration
target_config_file = env.GetBuildPath('#/Build/Targets/'+env['target']+'/Config.scons')
if os.path.exists(target_config_file):
    # Load the target-specific config file    
    execfile(target_config_file)

#######################################################
# modules
#######################################################
# Neptune
NPT_SOURCE_ROOT = 'ThirdParty/Neptune/Source'
if env['build_config'] == 'Debug':
    NPT_EXTRA_CPP_DEFINES = {}
else:
    NPT_EXTRA_CPP_DEFINES = {}
    
LibraryModule   (name                  = 'Neptune',
                 build_source_dirs     = ['Core'],
                 build_source_files    = env['NPT_SYSTEM_SOURCES'],
                 linked_modules        = env['NPT_EXTRA_LIBS'],
                 source_root           = NPT_SOURCE_ROOT,
                 extra_cpp_defines     = NPT_EXTRA_CPP_DEFINES)
                 
# Platinum
PLT_SOURCE_ROOT = 'Source'           
LibraryModule   (name               = 'Platinum',
                 build_source_dirs  = ['Core'],
                 included_modules   = ['Neptune'],
                 linked_modules     = ['Neptune'],
                 excluded_files	    = ['PltRingBufferStream.cpp', 'PltStreamPump.cpp'],
                 source_root        = PLT_SOURCE_ROOT)
                 
# Platinum MediaServer
PLT_MS_SOURCE_ROOT = 'Source/Devices'           
LibraryModule   (name               = 'PltMediaServer',
                 build_source_dirs  = ['MediaServer'],
                 included_modules   = ['Neptune', 'Platinum'],
                 linked_modules     = ['Neptune', 'Platinum'],
                 source_root        = PLT_MS_SOURCE_ROOT)

# Platinum MediaRenderer
PLT_MR_SOURCE_ROOT = 'Source/Devices'           
LibraryModule   (name               = 'PltMediaRenderer',
                 build_source_dirs  = ['MediaRenderer'],
                 included_modules   = ['Neptune', 'Platinum', 'PltMediaServer'],
                 linked_modules     = ['Neptune', 'Platinum'],
                 source_root        = PLT_MR_SOURCE_ROOT)
                                           
for app in ['MicroMediaController', 'MediaCrawler']:
    BuildApp(name = app, 
             source_dirs = 'Source/Apps/' + app, 
             deps = ['Neptune', 'Platinum', 'PltMediaServer', 'PltMediaRenderer'])
    
for test in ['FileMediaServer', 'MediaRenderer', 'LightSample', 'Http']:
    BuildApp(name = test+'Test', 
             source_dirs = 'Source/Tests/' + test, 
             deps = ['Neptune', 'Platinum', 'PltMediaServer', 'PltMediaRenderer'])
    		 
for tool in ['SsdpProxy', 'TextToHeader']:
    BuildApp(name = tool, 
             source_dirs = 'Source/Tools/' + tool, 
             deps = ['Neptune', 'Platinum'])
