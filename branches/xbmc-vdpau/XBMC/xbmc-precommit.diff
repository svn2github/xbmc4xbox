Index: XBMC/configure
===================================================================
--- XBMC/configure	(revision 17697)
+++ XBMC/configure	(working copy)
@@ -2140,7 +2140,14 @@
   use_mid=no
 fi
 
+# Check whether --enable-vdpau was given.
+if test "${enable_vdpau+set}" = set; then
+  enableval=$enable_vdpau; use_vdpau=$enableval
+else
+  use_vdpau=yes
+fi
 
+
 # PCRE is a requirement
 use_pcre="yes"
 
@@ -14913,6 +14920,13 @@
   final_message="$final_message\n  MID Support:\tNo"
 fi
 
+if test "$use_vdpau" = "yes"; then
+  final_message="$final_message\n  VDPAU Support:Yes"
+  LIBS="-lvdpau $LIBS"
+else
+  final_message="$final_message\n  VDPAU Support:No"
+fi
+
 if test -d "/usr/include/lzo"; then
   LZO_INCLUDES="$LZO_INCLUDES -I/usr/include/lzo"
 else
@@ -16515,7 +16529,7 @@
       --disable-altivec \
       --disable-vhook \
       --disable-ipv6 \
-      --disable-debug \
+      --enable-debug \
       --disable-muxers \
       --disable-encoders \
       --disable-devices \
Index: XBMC/language/English/strings.xml
===================================================================
--- XBMC/language/English/strings.xml	(revision 17697)
+++ XBMC/language/English/strings.xml	(working copy)
@@ -1176,6 +1176,7 @@
   <string id="13417">Basic shaders (ARB)</string>
   <string id="13418">Advanced shaders (GLSL)</string>
   <string id="13419">Software</string>
+  <string id="13420">VDPAU</string>
 
   <string id="13600">Apple Remote</string>
   <string id="13601">Mode</string>
Index: XBMC/XBMC.xcodeproj/project.pbxproj
===================================================================
--- XBMC/XBMC.xcodeproj/project.pbxproj	(revision 17697)
+++ XBMC/XBMC.xcodeproj/project.pbxproj	(working copy)
@@ -86,6 +86,7 @@
 		88ECB6EA0DE07BEE003396A7 /* libogg.0.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 88ECB6E90DE07BEE003396A7 /* libogg.0.dylib */; };
 		88ECB6EC0DE07C56003396A7 /* libmysqlclient.15.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 88ECB6EB0DE07C56003396A7 /* libmysqlclient.15.dylib */; };
 		8DD76F790486A8DE00D96B5E /* CoreFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 09AB6884FE841BABC02AAC07 /* CoreFoundation.framework */; };
+		D04943CC0F4219B700B73A8B /* DVDVideoCodecFFmpegVDPAU.cpp in Sources */ = {isa = PBXBuildFile; fileRef = D04943CB0F4219B700B73A8B /* DVDVideoCodecFFmpegVDPAU.cpp */; };
 		E306D12E0DDF7B590052C2AD /* XBMCHelper.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E306D12C0DDF7B590052C2AD /* XBMCHelper.cpp */; };
 		E33206380D5070AA00435CE3 /* DVDDemuxVobsub.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E33206370D5070AA00435CE3 /* DVDDemuxVobsub.cpp */; };
 		E33466A60D2E5103005A65EC /* IOKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = E33466A50D2E5103005A65EC /* IOKit.framework */; };
@@ -990,6 +991,8 @@
 		88ECB6E90DE07BEE003396A7 /* libogg.0.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libogg.0.dylib; path = /opt/local/lib/libogg.0.dylib; sourceTree = "<absolute>"; };
 		88ECB6EB0DE07C56003396A7 /* libmysqlclient.15.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libmysqlclient.15.dylib; path = /opt/local/lib/mysql5/mysql/libmysqlclient.15.dylib; sourceTree = "<absolute>"; };
 		8DD76F7E0486A8DE00D96B5E /* XBMC */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = XBMC; sourceTree = BUILT_PRODUCTS_DIR; };
+		D04943CA0F4219B700B73A8B /* DVDVideoCodecFFmpegVDPAU.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DVDVideoCodecFFmpegVDPAU.h; sourceTree = "<group>"; };
+		D04943CB0F4219B700B73A8B /* DVDVideoCodecFFmpegVDPAU.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DVDVideoCodecFFmpegVDPAU.cpp; sourceTree = "<group>"; };
 		E306D12C0DDF7B590052C2AD /* XBMCHelper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = XBMCHelper.cpp; sourceTree = "<group>"; };
 		E306D12D0DDF7B590052C2AD /* XBMCHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = XBMCHelper.h; sourceTree = "<group>"; };
 		E30B3E8E0D5D59290030A311 /* libShout-osx.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = "libShout-osx.a"; path = "xbmc/lib/libshout/libShout-osx.a"; sourceTree = "<group>"; };
@@ -3906,6 +3909,8 @@
 				E38E15410D25F9F900618676 /* DVDVideoPPFFmpeg.cpp */,
 				E38E15420D25F9F900618676 /* DVDVideoPPFFmpeg.h */,
 				E38E15430D25F9F900618676 /* libmpeg2 */,
+				D04943CA0F4219B700B73A8B /* DVDVideoCodecFFmpegVDPAU.h */,
+				D04943CB0F4219B700B73A8B /* DVDVideoCodecFFmpegVDPAU.cpp */,
 			);
 			path = Video;
 			sourceTree = "<group>";
@@ -6625,6 +6630,7 @@
 				F5390F7A0F2BB7080081BAE0 /* Cdg.cpp in Sources */,
 				7CEBD8A80F33A0D800CAF6AD /* SpecialProtocolDirectory.cpp in Sources */,
 				7C2D6AE40F35453E00DD2E85 /* SpecialProtocol.cpp in Sources */,
+				D04943CC0F4219B700B73A8B /* DVDVideoCodecFFmpegVDPAU.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
Index: XBMC/xbmc/GUISettings.h
===================================================================
--- XBMC/xbmc/GUISettings.h	(revision 17697)
+++ XBMC/xbmc/GUISettings.h	(working copy)
@@ -30,7 +30,8 @@
 #define RENDER_METHOD_AUTO      0
 #define RENDER_METHOD_ARB       1
 #define RENDER_METHOD_GLSL      2
-#define RENDER_METHOD_SOFTWARE  3
+#define RENDER_METHOD_VDPAU     3
+#define RENDER_METHOD_SOFTWARE  4
 #define RENDER_OVERLAYS         99   // to retain compatibility
 
 // Scaling options.
Index: XBMC/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
===================================================================
--- XBMC/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp	(revision 17697)
+++ XBMC/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp	(working copy)
@@ -30,16 +30,40 @@
 #include "../../XBVideoConfig.h"
 #include "../../../guilib/Surface.h"
 #include "../../../guilib/FrameBufferObject.h"
+#include <X11/xpm.h>
+#include "../dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h"
 
 #define ALIGN(value, alignment) (((value)+((alignment)-1))&~((alignment)-1))
 
 #ifdef HAS_SDL_OPENGL
 
+#define CHECK_GL \
+  rv = glGetError(); \
+  if (rv) \
+    CLog::Log(LOGERROR, "openGL Error: %i",rv);
+
+bool usingVDPAU;
+CDVDVideoCodecVDPAU* m_VDPAU;
+
+
+MATRIX identity_matrix = {
+    1.0f, 0.0f,
+    0.0f, 1.0f,
+    0.0f, 0.0f
+};
+
 using namespace Surface;
 using namespace Shaders;
+bool debugSpew=false;
+bool spamtastic=false;
+CSurface *m_Surface = NULL;
 
 CLinuxRendererGL::CLinuxRendererGL()
 {
+
+  if (!m_Surface) m_Surface = new CSurface(g_graphicsContext.getScreenSurface());
+
+  m_pVdpauTexture = (VideoTexture*) malloc (sizeof (VideoTexture));
   m_pBuffer = NULL;
   m_textureTarget = GL_TEXTURE_2D;
   m_fSourceFrameRatio = 1.0f;
@@ -51,7 +75,6 @@
 
     // possibly not needed?
     m_eventTexturesDone[i] = CreateEvent(NULL,FALSE,TRUE,NULL);
-    //m_eventOSDDone[i] = CreateEvent(NULL,TRUE,TRUE,NULL);
   }
 
   m_fragmentShader = 0;
@@ -61,6 +84,7 @@
   m_uTex = 0;
   m_vTex = 0;
   m_iFlags = 0;
+  imagenumber = 0;
 
   m_iYV12RenderBuffer = 0;
   m_pOSDYBuffer = NULL;
@@ -75,7 +99,6 @@
   m_upscalingHeight = 0;
   memset(&m_imScaled, 0, sizeof(m_imScaled));
   m_isSoftwareUpscaling = false;
-
   memset(m_image, 0, sizeof(m_image));
   memset(m_YUVTexture, 0, sizeof(m_YUVTexture));
 
@@ -109,7 +132,17 @@
     free(m_pOSDABuffer);
     m_pOSDABuffer = NULL;
   }
-  
+  if (m_pVdpauTexture)
+  {
+    free (m_pVdpauTexture);
+    m_pVdpauTexture = NULL;
+  }
+  if (m_Surface)
+  {
+    CLog::Log(LOGNOTICE,"Deleting m_Surface in CLinuxRendererGL");
+    delete m_Surface;
+    m_Surface = NULL;
+  }
   for (int i=0; i<3; i++)
   {
     if (m_imScaled.plane[i])
@@ -428,7 +461,7 @@
   glColor3f(1.0, 1.0, 1.0);
   glTexCoord2f(0.0, 0.0);
   glVertex2f(osdRect.left, osdRect.top);
-  glTexCoord2f(1.0, 0.0);
+
   glVertex2f(osdRect.right, osdRect.top);
   glTexCoord2f(1.0, 1.0);
   glVertex2f(osdRect.right, osdRect.bottom);
@@ -566,8 +599,13 @@
   {
     if (!glewIsSupported("GL_ARB_texture_non_power_of_two") && glewIsSupported("GL_ARB_texture_rectangle"))
     {
+      CLog::Log(LOGNOTICE,"Using GL_TEXTURE_RECTANGLE_ARB");
       m_textureTarget = GL_TEXTURE_RECTANGLE_ARB;
     }
+    else
+     {
+       CLog::Log(LOGNOTICE,"Using GL_TEXTURE_2D");
+     }
 
      // create the yuv textures    
     LoadShaders();
@@ -701,6 +739,74 @@
   return true;
 }
 
+bool
+CLinuxRendererGL::bindPixmapToTexture (VideoTexture *texture,
+                                       Pixmap       pixmap,
+                                       int          width,
+                                       int          height,
+                                       int          depth)
+{
+  texture->GLpixmap = m_Surface->GetGLPixmap();
+  texture->name = m_Surface->GetGLPixmapTex();
+  texture->target = GL_TEXTURE_RECTANGLE_ARB;
+  texture->matrix.xx = 1.0f;
+  //assume y-inverted
+  texture->matrix.yy = 1.0f;
+  texture->matrix.y0 = 0;
+  texture->mipmap = FALSE;
+  m_Surface->BindPixmap();
+  texture->filter = GL_NEAREST;
+  
+  glTexParameteri (texture->target, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  glTexParameteri (texture->target, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+  
+  glTexParameteri (texture->target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri (texture->target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  
+  texture->wrap = GL_CLAMP_TO_EDGE;
+  glBindTexture (texture->target, 0);
+  
+  return TRUE;
+}
+
+VideoTexture *
+CLinuxRendererGL::vdpauGetTexture (Pixmap pixmap)
+{
+  unsigned int width, height, depth, ui;
+  Window	 root;
+  int		 i;
+  Display* pD = glXGetCurrentDisplay();
+
+  if (m_pVdpauTexture->pixmap == pixmap)
+   {
+     m_pVdpauTexture->refCount++;
+     return m_pVdpauTexture;
+   }
+
+  m_pVdpauTexture->pixmap = pixmap;
+  m_pVdpauTexture->refCount = 1;
+  m_pVdpauTexture->name = 0;
+  m_pVdpauTexture->target = GL_TEXTURE_RECTANGLE_ARB;
+  m_pVdpauTexture->GLpixmap = None;
+  m_pVdpauTexture->filter = GL_NEAREST;
+  m_pVdpauTexture->wrap = GL_CLAMP_TO_EDGE;
+  m_pVdpauTexture->matrix = identity_matrix;
+  m_pVdpauTexture->oldMipmaps = TRUE;
+  m_pVdpauTexture->mipmap = FALSE;
+
+  XGetGeometry(pD, pixmap, &root,
+               &i, &i, &width, &height, &ui, &depth);
+
+  bindPixmapToTexture(m_pVdpauTexture, pixmap,
+                      width, height, depth);
+  m_pVdpauTexture->refCount = 1;
+  m_pVdpauTexture->pixmap   = pixmap;
+  m_pVdpauTexture->width    = width;
+  m_pVdpauTexture->height   = height;
+
+  return m_pVdpauTexture;
+}
+
 int CLinuxRendererGL::NextYV12Texture()
 {
   return (m_iYV12RenderBuffer + 1) % m_NumYV12Buffers;
@@ -711,6 +817,9 @@
   if (!image) return -1;
   if (!m_bValidated) return -1;
 
+  if (m_VDPAU)
+    m_VDPAU->VDPAUPrePresent();
+
   /* take next available buffer */
   if( source == AUTOSOURCE )
     source = NextYV12Texture();
@@ -755,12 +864,12 @@
 
     return source;
   }
-
   return -1;
 }
 
 void CLinuxRendererGL::ReleaseImage(int source, bool preserve)
 {
+  m_VDPAU->VDPAUPresent();
   if( m_image[source].flags & IMAGE_FLAG_WRITING )
     SetEvent(m_eventTexturesDone[source]);
 
@@ -778,7 +887,11 @@
 {
   YV12Image* im = &m_image[source];
   YUVFIELDS& fields = m_YUVTexture[source];
-
+  if (m_renderMethod & RENDER_VDPAU)
+  {
+    SetEvent(m_eventTexturesDone[source]);
+    return;
+  }
   if (!(im->flags&IMAGE_FLAG_READY))
   {
     SetEvent(m_eventTexturesDone[source]);
@@ -790,22 +903,12 @@
   {
     for (int i = 0 ; i < m_NumYV12Buffers ; i++)
       CreateYV12Texture(i);
-    
     im->flags = IMAGE_FLAG_READY;
   }
-  
+
   // if we don't have a shader, fallback to SW YUV2RGB for now
   if (m_renderMethod & RENDER_SW)
   {
-    struct SwsContext *context = m_dllSwScale.sws_getContext(im->width, im->height, PIX_FMT_YUV420P,
-                                                             im->width, im->height, PIX_FMT_RGB32,
-                                                             SWS_FAST_BILINEAR, NULL, NULL, NULL);
-    uint8_t *src[] = { im->plane[0], im->plane[1], im->plane[2] };
-    int     srcStride[] = { im->stride[0], im->stride[1], im->stride[2] };
-    uint8_t *dst[] = { m_rgbBuffer, 0, 0 };
-    int     dstStride[] = { m_iSourceWidth*4, 0, 0 };
-    m_dllSwScale.sws_scale(context, src, srcStride, 0, im->height, dst, dstStride);
-    m_dllSwScale.sws_freeContext(context);
     SetEvent(m_eventTexturesDone[source]);
   }
   else if (IsSoftwareUpscaling()) // FIXME: s/w upscaling + RENDER_SW => broken
@@ -834,7 +937,7 @@
     im = &m_imScaled;
     im->flags = IMAGE_FLAG_READY;
   }
-  
+
   static int imaging = -1;
   static GLfloat brightness = 0;
   static GLfloat contrast   = 0;
@@ -914,8 +1017,6 @@
     {
       glPixelStorei(GL_UNPACK_ROW_LENGTH, im->stride[0]);
       glBindTexture(m_textureTarget, fields[FIELD_FULL][0]);
-      glTexSubImage2D(m_textureTarget, 0, 0, 0, im->width, im->height, GL_BGRA, GL_UNSIGNED_BYTE, m_rgbBuffer);
-
       glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
       VerifyGLState();
     }
@@ -1036,8 +1137,10 @@
   if (!m_bConfigured) return;
 
   // if its first pass, just init textures and return
-  if (ValidateRenderTarget())
+  if (ValidateRenderTarget()) {
+    if (debugSpew) CLog::Log(LOGNOTICE,"%s ValidateRenderTarget call returned false",__FUNCTION__);
     return;
+  }
 
   // this needs to be checked after texture validation
   if (!m_bImageReady) return;
@@ -1263,6 +1366,16 @@
   CLog::Log(LOGDEBUG, "GL: Requested render method: %d", requestedMethod);
   bool err = false;
 
+  if (requestedMethod==RENDER_METHOD_VDPAU)
+  {
+    if (!usingVDPAU) {
+      requestedMethod = RENDER_METHOD_AUTO;
+    }
+    else {
+      requestedMethod = RENDER_METHOD_SOFTWARE;
+    }
+  }
+
   /*
     Try GLSL shaders if they're supported and if the user has
     requested for it. (settings -> video -> player -> rendermethod)
@@ -1351,6 +1464,11 @@
       CLog::Log(LOGERROR, "GL: Error enabling YUV2RGB ARB shader");
     }
   }
+  else if (requestedMethod == RENDER_METHOD_VDPAU)
+  {
+    CLog::Log(LOGNOTICE, "GL: Using VDPAU render method");
+    m_renderMethod = RENDER_VDPAU;
+  }
 
   /*
     Fall back to software YUV 2 RGB conversion if
@@ -1488,6 +1606,10 @@
   {
     RenderSinglePass(flags, renderBuffer);
   }
+  else if (m_renderMethod & RENDER_VDPAU)
+  {
+    RenderVDPAU(flags, renderBuffer);
+  }
   else
   {
     RenderSoftware(flags, renderBuffer);
@@ -2020,6 +2142,55 @@
   VerifyGLState();
 }
 
+void CLinuxRendererGL::RenderVDPAU(DWORD flags, int index)
+{
+  if ( !(g_graphicsContext.IsFullScreenVideo() || g_graphicsContext.IsCalibrating() ))
+  {
+    g_graphicsContext.ClipToViewWindow();
+  }
+
+  glDisable(GL_DEPTH_TEST);
+
+  if (!m_Surface) return;
+
+  VideoTexture* vt = vdpauGetTexture(m_Surface->GetXPixmap());
+  VerifyGLState();
+
+  glEnable(m_textureTarget);
+  VerifyGLState();
+  glActiveTextureARB(GL_TEXTURE0);
+  VerifyGLState();
+
+  if (vt) glBindTexture(m_textureTarget, m_Surface->GetGLPixmapTex() );
+  VerifyGLState();
+
+  // Try some clamping or wrapping
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+
+  //glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL | GL_REPLACE);
+
+  glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
+  VerifyGLState();
+  glEnable(m_textureTarget);
+  glBegin(GL_QUADS);
+
+  if (m_textureTarget==GL_TEXTURE_2D)
+  {
+    glTexCoord2f(0.0, 0.0);  glVertex2d((float)rd.left, (float)rd.top);
+    glTexCoord2f(1.0, 0.0);  glVertex2d((float)rd.right, (float)rd.top);
+    glTexCoord2f(1.0, 1.0);  glVertex2d((float)rd.right, (float)rd.bottom);
+    glTexCoord2f(0.0, 1.0);  glVertex2d((float)rd.left, (float)rd.bottom);
+  }
+  glEnd();
+  VerifyGLState();
+  glDisable(m_textureTarget);
+  VerifyGLState();
+}
+
+
 void CLinuxRendererGL::RenderSoftware(DWORD flags, int index)
 {
   int field = FIELD_FULL;
@@ -2253,7 +2424,8 @@
     np2y = NP2((im.height / divfactor));
 
     glBindTexture(m_textureTarget, fields[f][0]);
-    if (m_renderMethod & RENDER_SW)
+    if ((m_renderMethod & RENDER_SW) | (m_renderMethod & RENDER_VDPAU))
+    //if (1==1)
     {
       // require Power Of Two textures?
       if (m_renderMethod & RENDER_POT)
@@ -2296,6 +2468,7 @@
     VerifyGLState();
 
     if (!(m_renderMethod & RENDER_SW))
+    //if (!(1==1))
     {
       glBindTexture(m_textureTarget, fields[f][1]);
 
Index: XBMC/xbmc/cores/VideoRenderers/RenderManager.cpp
===================================================================
--- XBMC/xbmc/cores/VideoRenderers/RenderManager.cpp	(revision 17697)
+++ XBMC/xbmc/cores/VideoRenderers/RenderManager.cpp	(working copy)
@@ -48,7 +48,6 @@
 
 CXBoxRenderManager g_renderManager;
 
-
 #define MAXPRESENTDELAY 0.500
 
 /* at any point we want an exclusive lock on rendermanager */
Index: XBMC/xbmc/cores/VideoRenderers/LinuxRendererGL.h
===================================================================
--- XBMC/xbmc/cores/VideoRenderers/LinuxRendererGL.h	(revision 17697)
+++ XBMC/xbmc/cores/VideoRenderers/LinuxRendererGL.h	(working copy)
@@ -11,7 +11,16 @@
 #include "VideoShaders/VideoFilterShader.h"
 #include "../../settings/VideoSettings.h"
 #include "RenderFlags.h"
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include "../ffmpeg/vdpau_render.h"
 
+#ifdef HAS_SDL_OPENGL
+#include <GL/glew.h>
+#endif
+#ifdef HAS_GLX
+#include <GL/glx.h>
+#endif
 namespace Surface { class CSurface; }
 
 using namespace Surface;
@@ -40,6 +49,30 @@
   unsigned cshift_y;
 } YV12Image;
 
+typedef struct _MATRIX {
+    float xx; float yx;
+    float xy; float yy;
+    float x0; float y0;
+} MATRIX;
+
+typedef struct _VideoTexture {
+    int        refCount;
+    Pixmap     pixmap;
+    int        width;
+    int        height;
+    GLuint     name;
+    GLenum     target;
+    GLfloat    dx, dy;
+    GLXPixmap  GLpixmap;
+    GLXContext context;
+    GLenum     filter;
+    GLenum     wrap;
+    MATRIX     matrix;
+    Bool       oldMipmaps;
+    Bool       mipmap;
+} VideoTexture;
+
+
 #define AUTOSOURCE -1
 
 #define IMAGE_FLAG_WRITING   0x01 /* image is in use after a call to GetImage, caller may be reading or writing */
@@ -49,6 +82,7 @@
 #define IMAGE_FLAG_READY     0x16 /* image is ready to be uploaded to texture memory */
 #define IMAGE_FLAG_INUSE (IMAGE_FLAG_WRITING | IMAGE_FLAG_READING | IMAGE_FLAG_RESERVED)
 
+
 struct DRAWRECT
 {
   float left;
@@ -84,6 +118,7 @@
   RENDER_GLSL=0x01,
   RENDER_ARB=0x02,
   RENDER_SW=0x04,
+  RENDER_VDPAU=0x05,
   RENDER_POT=0x10
 };
 
@@ -109,6 +144,7 @@
 extern YUVCOEF yuv_coef_bt709;
 extern YUVCOEF yuv_coef_ebu;
 extern YUVCOEF yuv_coef_smtp240m;
+extern CSurface *m_Surface;
 
 class CLinuxRendererGL
 {
@@ -135,10 +171,12 @@
   virtual void         UnInit();
   virtual void         OnClose(); // called from main GUI thread
   virtual void         Reset(); /* resets renderer after seek for example */
-
+  bool bindPixmapToTexture(VideoTexture *texture, Pixmap pixmap, int width, int height, int depth);
+  VideoTexture* vdpauGetTexture(Pixmap pixmap);
   void AutoCrop(bool bCrop);
   virtual void RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
-  RESOLUTION GetResolution();  
+  RESOLUTION GetResolution();
+  int imagenumber;
 
   // Feature support
   virtual bool SupportsBrightness();
@@ -172,12 +210,14 @@
   void LoadTextures(int source);
   void SetTextureFilter(GLenum method);
   void UpdateVideoFilter();
+  Display   *dpy;
 
   // renderers
   //void RenderLowMem(DWORD flags);     // low mem renderer
   void RenderMultiPass(DWORD flags, int renderBuffer);  // multi pass glsl renderer
   void RenderSinglePass(DWORD flags, int renderBuffer); // single pass glsl renderer
   void RenderSoftware(DWORD flags, int renderBuffer);   // single pass s/w yuv2rgb renderer
+  void RenderVDPAU(DWORD flags, int renderBuffer);   // single pass s/w yuv2rgb renderer
 
   CFrameBufferObject m_fbo;
   CSurface *m_pBuffer;
@@ -214,6 +254,8 @@
   GLubyte* m_pOSDYBuffer;
   GLubyte* m_pOSDABuffer;
 
+  VideoTexture *m_pVdpauTexture;
+
   float m_OSDWidth;
   float m_OSDHeight;
   DRAWRECT m_OSDRect;
@@ -271,7 +313,6 @@
 
   HANDLE m_eventTexturesDone[NUM_BUFFERS];
   HANDLE m_eventOSDDone[NUM_BUFFERS];
-
 };
 
 
Index: XBMC/xbmc/cores/VideoRenderers/RenderManager.h
===================================================================
--- XBMC/xbmc/cores/VideoRenderers/RenderManager.h	(revision 17697)
+++ XBMC/xbmc/cores/VideoRenderers/RenderManager.h	(working copy)
@@ -45,6 +45,7 @@
   void Update(bool bPauseDrawing);
   void RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
   void SetupScreenshot();
+  
 
 #ifndef HAS_SDL
   void CreateThumbnail(LPDIRECT3DSURFACE8 surface, unsigned int width, unsigned int height);
@@ -129,6 +130,7 @@
 
 #ifdef HAS_SDL_OPENGL
   CLinuxRendererGL *m_pRenderer;
+  CLinuxRendererGL *GetRenderer() {return m_pRenderer; };
 #elif defined(HAS_SDL)
   CLinuxRenderer *m_pRenderer;
 #else
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavutil/avutil.h
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavutil/avutil.h	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavutil/avutil.h	(working copy)
@@ -121,6 +121,15 @@
     PIX_FMT_YUV440P,   ///< Planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
     PIX_FMT_YUVJ440P,  ///< Planar YUV 4:4:0 full scale (jpeg)
     PIX_FMT_YUVA420P,  ///< Planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
+    PIX_FMT_VDPAU_MPEG1,
+    PIX_FMT_VDPAU_MPEG2_SIMPLE,
+    PIX_FMT_VDPAU_MPEG2_MAIN,
+    PIX_FMT_VDPAU_H264_BASELINE,
+    PIX_FMT_VDPAU_H264_MAIN,
+    PIX_FMT_VDPAU_H264_HIGH,
+    PIX_FMT_VDPAU_VC1_SIMPLE,
+    PIX_FMT_VDPAU_VC1_MAIN,
+    PIX_FMT_VDPAU_VC1_ADVANCED,
     PIX_FMT_NB,        ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vc1_parser.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vc1_parser.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vc1_parser.c	(working copy)
@@ -109,7 +109,8 @@
 }
 
 AVCodecParser vc1_parser = {
-    { CODEC_ID_VC1 },
+    { CODEC_ID_VC1,
+      CODEC_ID_VC1_VDPAU },
     sizeof(ParseContext1),
     NULL,
     vc1_parse,
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/utils.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/utils.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/utils.c	(working copy)
@@ -646,6 +646,7 @@
 {"context", "context model", OFFSET(context_model), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, V|E},
 {"slice_flags", NULL, OFFSET(slice_flags), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX},
 {"xvmc_acceleration", NULL, OFFSET(xvmc_acceleration), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX},
+{"vdpau_acceleration", NULL, OFFSET(vdpau_acceleration), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX},
 {"mbd", "macroblock decision algorithm (high quality mode)", OFFSET(mb_decision), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, V|E, "mbd"},
 {"simple", "use mbcmp (default)", 0, FF_OPT_TYPE_CONST, FF_MB_DECISION_SIMPLE, INT_MIN, INT_MAX, V|E, "mbd"},
 {"bits", "use fewest bits", 0, FF_OPT_TYPE_CONST, FF_MB_DECISION_BITS, INT_MIN, INT_MAX, V|E, "mbd"},
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h264.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h264.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h264.c	(working copy)
@@ -41,6 +41,7 @@
 
 //#undef NDEBUG
 #include <assert.h>
+#include <stdio.h>
 
 /**
  * Value of Picture.reference when Picture is not a reference picture, but
@@ -72,6 +73,9 @@
 static VLC_TYPE run7_vlc_table[96][2];
 static const int run7_vlc_table_size = 96;
 
+int VDPAU_h264_add_data_chunk(H264Context *h, const uint8_t *buf, int buf_size);
+int VDPAU_h264_picture_complete(H264Context *h);
+
 static void svq3_luma_dc_dequant_idct_c(DCTELEM *block, int qp);
 static void svq3_add_idct_c(uint8_t *dst, DCTELEM *block, int stride, int qp, int dc);
 static void filter_mb( H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize);
@@ -101,6 +105,17 @@
     {0,2,0,2,7,10,7,10}
 };
 
+static const enum PixelFormat pixfmt_vdpau_h264_baseline_420[] = {
+                                           PIX_FMT_VDPAU_H264_BASELINE,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_h264_main_420[] = {
+                                           PIX_FMT_VDPAU_H264_MAIN,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_h264_high_420[] = {
+                                           PIX_FMT_VDPAU_H264_HIGH,
+                                           PIX_FMT_NONE};
+
+
 #define LEVEL_TAB_BITS 8
 static int8_t cavlc_level_tab[7][1<<LEVEL_TAB_BITS][2];
 
@@ -2186,7 +2201,9 @@
     s->quarter_sample = 1;
     s->low_delay= 1;
 
-    if(avctx->codec_id == CODEC_ID_SVQ3)
+    if(avctx->vdpau_acceleration)
+        avctx->pix_fmt = PIX_FMT_NONE; // Set in decode_postinit() later
+    else if(avctx->codec_id == CODEC_ID_SVQ3)
         avctx->pix_fmt= PIX_FMT_YUVJ420P;
     else
         avctx->pix_fmt= PIX_FMT_YUV420P;
@@ -2207,6 +2224,25 @@
     return 0;
 }
 
+static int decode_postinit(H264Context *h, SPS *sps){
+    AVCodecContext * const avctx= h->s.avctx;
+
+    if(h->s.chroma_format >= 2) {
+        return -2;
+    }
+    if (sps->profile_idc == 66) {
+        avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_h264_baseline_420);
+    } else if (sps->profile_idc == 77) {
+        avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_h264_main_420);
+    } else if (sps->profile_idc == 100) {
+        avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_h264_high_420);
+    } else {
+        return -2;
+    }
+
+    return 0;
+}
+
 static int frame_start(H264Context *h){
     MpegEncContext * const s = &h->s;
     int i;
@@ -7367,6 +7403,10 @@
                ((const char*[]){"Gray","420","422","444"})[sps->chroma_format_idc]
                );
     }
+
+    if (s->avctx->vdpau_acceleration && (s->avctx->pix_fmt == PIX_FMT_NONE) && (decode_postinit(h, sps) < 0))
+        return -1;
+
     av_free(h->sps_buffers[sps_id]);
     h->sps_buffers[sps_id]= sps;
     return 0;
@@ -7511,8 +7551,9 @@
     H264Context *hx;
     int i;
 
-    if(context_count == 1)
-    {
+    if(avctx->vdpau_acceleration) {
+        return;
+	} else if(context_count == 1) {
         if(avctx->thread_count > 1 && h->pps.cabac && !FIELD_OR_MBAFF_PICTURE) //Multi thread patch does not like Interlaced picture
             decode_slice2(avctx, &h);
         else
@@ -7644,8 +7685,24 @@
                && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)
                && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=FF_B_TYPE)
                && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==FF_I_TYPE)
-               && avctx->skip_frame < AVDISCARD_ALL)
-                context_count++;
+               && avctx->skip_frame < AVDISCARD_ALL) {
+                if (avctx->vdpau_acceleration) {
+                    if(h->is_avc) {
+                        static const uint8_t start_code[] = {0x00, 0x00, 0x01};
+                        VDPAU_h264_add_data_chunk(h, start_code, sizeof(start_code));
+                        VDPAU_h264_add_data_chunk(h, &buf[buf_index - consumed], consumed );
+                    }
+                    else
+                    {
+                        // +/-3: Add back 00 00 01 to start of data
+                        VDPAU_h264_add_data_chunk(h, &buf[buf_index - consumed - 3], consumed + 3);
+                    }
+                }
+                else
+                {
+                    context_count++;
+                }
+            }
             break;
         case NAL_DPA:
             init_get_bits(&hx->s.gb, ptr, bit_length);
@@ -7848,6 +7905,10 @@
         h->prev_frame_num_offset= h->frame_num_offset;
         h->prev_frame_num= h->frame_num;
 
+        if (avctx->vdpau_acceleration) {
+            VDPAU_h264_picture_complete(h);
+        }
+
         /*
          * FIXME: Error handling code does not seem to support interlaced
          * when slices span multiple rows
@@ -7860,8 +7921,9 @@
          * past end by one (callers fault) and resync_mb_y != 0
          * causes problems for the first MB line, too.
          */
-        if (!FIELD_PICTURE)
-            ff_er_frame_end(s);
+        if (!avctx->vdpau_acceleration)
+            if (!FIELD_PICTURE)
+                ff_er_frame_end(s);
 
         MPV_frame_end(s);
 
@@ -8218,19 +8280,49 @@
     return 0;
 }
 
+#define HAVE_VDPAU 1
+AVCodec h264_decoder = {
+  "h264",
+  CODEC_TYPE_VIDEO,
+  CODEC_ID_H264,
+  sizeof(H264Context),
+  decode_init,
+  NULL,
+  decode_end,
+  decode_frame,
+  /*CODEC_CAP_DRAW_HORIZ_BAND |*/ CODEC_CAP_DR1 | CODEC_CAP_DELAY,
+  .flush= flush_dpb,
+  .long_name = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"),
+};
 
-AVCodec h264_decoder = {
-    "h264",
+#ifdef HAVE_VDPAU
+static av_cold int h264_vdpau_decode_init(AVCodecContext *avctx){
+    if( avctx->thread_count > 1)
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_CODED_ORDER) )
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD) ){
+        dprintf(avctx, "h264.c: VDPAU decoder does not set SLICE_FLAG_ALLOW_FIELD\n");
+    }
+    avctx->vdpau_acceleration = 1;
+    decode_init(avctx);
+
+    return 0;
+}
+
+AVCodec h264_vdpau_decoder = {
+    "h264_vdpau",
     CODEC_TYPE_VIDEO,
-    CODEC_ID_H264,
+    CODEC_ID_H264_VDPAU,
     sizeof(H264Context),
-    decode_init,
+    h264_vdpau_decode_init,
     NULL,
     decode_end,
     decode_frame,
-    /*CODEC_CAP_DRAW_HORIZ_BAND |*/ CODEC_CAP_DR1 | CODEC_CAP_DELAY,
+    CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,
     .flush= flush_dpb,
-    .long_name = "H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10",
+    .long_name = NULL_IF_CONFIG_SMALL("H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 (VDPAU acceleration)"),
 };
+#endif
 
 #include "svq3.c"
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h264.h
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h264.h	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h264.h	(working copy)
@@ -63,7 +63,7 @@
  * The maximum number of slices supported by the decoder.
  * must be a power of 2
  */
-#define MAX_SLICES 16
+#define MAX_SLICES 256
 
 #ifdef ALLOW_INTERLACE
 #define MB_MBAFF h->mb_mbaff
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/Makefile
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/Makefile	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/Makefile	(working copy)
@@ -98,7 +98,7 @@
 OBJS-$(CONFIG_H263I_DECODER)           += h263dec.o h263.o mpeg12data.o mpegvideo.o error_resilience.o
 OBJS-$(CONFIG_H263_ENCODER)            += mpegvideo_enc.o motion_est.o ratecontrol.o h263.o mpeg12data.o mpegvideo.o error_resilience.o
 OBJS-$(CONFIG_H263P_ENCODER)           += mpegvideo_enc.o motion_est.o ratecontrol.o h263.o mpeg12data.o mpegvideo.o error_resilience.o
-OBJS-$(CONFIG_H264_DECODER)            += h264.o h264idct.o h264pred.o h264_parser.o cabac.o mpegvideo.o error_resilience.o
+OBJS-$(CONFIG_H264_DECODER)            += vdpauvideo.o h264.o h264idct.o h264pred.o h264_parser.o cabac.o mpegvideo.o error_resilience.o
 OBJS-$(CONFIG_H264_ENCODER)            += h264enc.o h264dspenc.o
 OBJS-$(CONFIG_HUFFYUV_DECODER)         += huffyuv.o
 OBJS-$(CONFIG_HUFFYUV_ENCODER)         += huffyuv.o
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vdpauvideo.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vdpauvideo.c	(revision 0)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vdpauvideo.c	(revision 0)
@@ -0,0 +1,431 @@
+/*
+ * Video Decode and Presentation API for UNIX (VDPAU) is used for
+ * HW decode acceleration for MPEG-1/2, H.264 and VC-1.
+ *
+ * Copyright (c) 2008 NVIDIA.
+ *
+ * This file is part of FFmpeg.
+ *  
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */ 
+
+#include <limits.h>
+#include "avcodec.h"
+#include "dsputil.h"
+#include "mpegvideo.h"
+#include "h264.h"
+#include "vc1.h"
+
+#undef NDEBUG
+#include <assert.h>
+
+#include "vdpau_render.h"
+
+/**
+ * \addtogroup VDPAU_Decoding
+ *
+ * @
+ */
+
+static void VDPAU_ensure_has_buffers(vdpau_render_state_t * render, int need_entries)
+{
+    int new_alloced;
+
+    if (render->bitstreamBuffersAlloced >= need_entries) {
+        return;
+    }
+
+    if (!render->bitstreamBuffersAlloced || !render->bitstreamBuffers) {
+        new_alloced = 4;
+    }
+    else {
+        new_alloced = render->bitstreamBuffersAlloced * 2;
+    }
+
+    render->bitstreamBuffers = av_realloc(
+        render->bitstreamBuffers,
+        new_alloced * sizeof(render->bitstreamBuffers[0])
+    );
+    render->bitstreamBuffersAlloced = new_alloced;
+}
+
+int VDPAU_mpeg_field_start(MpegEncContext *s)
+{
+    vdpau_render_state_t * render,* last, * next;
+    int i;
+    
+    render = (vdpau_render_state_t*)s->current_picture.data[2];
+    assert(render != NULL);
+    assert(render->magic == MP_VDPAU_RENDER_MAGIC);
+    if ((render == NULL) || (render->magic != MP_VDPAU_RENDER_MAGIC)) {
+        return -1; // make sure that this is render packet
+    }
+
+    /* fill VdpPictureInfoMPEG1Or2 struct */
+    render->info.mpeg.picture_structure          = s->picture_structure;
+    render->info.mpeg.picture_coding_type        = s->pict_type;
+    render->info.mpeg.intra_dc_precision         = s->intra_dc_precision;
+    render->info.mpeg.frame_pred_frame_dct       = s->frame_pred_frame_dct;
+    render->info.mpeg.concealment_motion_vectors = s->concealment_motion_vectors;
+    render->info.mpeg.intra_vlc_format           = s->intra_vlc_format;
+    render->info.mpeg.alternate_scan             = s->alternate_scan;
+    render->info.mpeg.q_scale_type               = s->q_scale_type;
+    render->info.mpeg.top_field_first            = s->top_field_first;
+    render->info.mpeg.full_pel_forward_vector    = s->full_pel[0]; // MPEG-1 only.  Set 0 for MPEG-2
+    render->info.mpeg.full_pel_backward_vector   = s->full_pel[1]; // MPEG-1 only.  Set 0 for MPEG-2
+    render->info.mpeg.f_code[0][0]               = s->mpeg_f_code[0][0]; // For MPEG-1 fill both horiz. & vert.
+    render->info.mpeg.f_code[0][1]               = s->mpeg_f_code[0][1];
+    render->info.mpeg.f_code[1][0]               = s->mpeg_f_code[1][0];
+    render->info.mpeg.f_code[1][1]               = s->mpeg_f_code[1][1];
+    for (i = 0; i < 64; ++i) {
+        render->info.mpeg.intra_quantizer_matrix[i]     = s->intra_matrix[i];
+        render->info.mpeg.non_intra_quantizer_matrix[i] = s->inter_matrix[i];
+    }
+
+    render->info.mpeg.forward_reference  = VDP_INVALID_HANDLE;
+    render->info.mpeg.backward_reference = VDP_INVALID_HANDLE;
+
+    switch(s->pict_type){
+    case  FF_I_TYPE:
+        return 0; // no prediction from other frames
+    case  FF_B_TYPE:
+        next = (vdpau_render_state_t*)s->next_picture.data[2];
+        assert(next != NULL);
+        assert(next->magic == MP_VDPAU_RENDER_MAGIC);
+        if ((next == NULL) || (next->magic != MP_VDPAU_RENDER_MAGIC)) {
+            return -1;
+        }
+        render->info.mpeg.backward_reference = next->surface;
+        // no return here, going to set forward prediction
+    case  FF_P_TYPE:
+        last = (vdpau_render_state_t*)s->last_picture.data[2];
+        assert(last->magic == MP_VDPAU_RENDER_MAGIC);
+        if (last->magic != MP_VDPAU_RENDER_MAGIC) {
+            return -1;
+        }
+        if (last == NULL) { // FIXME: Does this test make sense?
+            last = render; // predict second field from the first
+        }
+        render->info.mpeg.forward_reference = last->surface;
+        return 0;
+    }
+
+    return -1;
+}
+
+int VDPAU_mpeg_picture_complete(MpegEncContext *s, const uint8_t *buf, int buf_size, int slice_count)
+{
+    vdpau_render_state_t * render;
+
+    render = (vdpau_render_state_t*)s->current_picture_ptr->data[2];
+    assert(render != NULL);
+    assert(render->magic == MP_VDPAU_RENDER_MAGIC);
+    if ((render == NULL) || (render->magic != MP_VDPAU_RENDER_MAGIC)) {
+        return -1; // make sure that this is render packet
+    }
+
+    VDPAU_ensure_has_buffers(render, 1);
+
+    render->bitstreamBuffers[0].struct_version  = VDP_BITSTREAM_BUFFER_VERSION;
+    render->bitstreamBuffers[0].bitstream_bytes = buf_size;
+    render->bitstreamBuffers[0].bitstream       = buf;
+    render->bitstreamBuffersUsed                = 1;
+
+    render->info.mpeg.slice_count               = slice_count;
+
+    if (slice_count > 0) {
+        ff_draw_horiz_band(s, 0, s->avctx->height);
+    }
+    render->bitstreamBuffersUsed = 0;
+
+    return 0;
+}
+
+int VDPAU_h264_set_reference_frames(H264Context *h)
+{
+    MpegEncContext * s = &h->s;
+    vdpau_render_state_t * render, * render_ref;
+    VdpReferenceFrameH264 * rf, * rf2;
+    Picture * pic;
+    int i, list;
+    uint16_t pic_frame_idx;
+
+    render = (vdpau_render_state_t*)s->current_picture_ptr->data[2];
+    assert(render != NULL);
+    assert(render->magic == MP_VDPAU_RENDER_MAGIC);
+    if ((render == NULL) || (render->magic != MP_VDPAU_RENDER_MAGIC))
+        return -1; // make sure that this is render packet
+
+    rf = &render->info.h264.referenceFrames[0];
+#define H264_RF_COUNT FF_ARRAY_ELEMS(render->info.h264.referenceFrames)
+
+    for (list = 0; list < 2; ++list) {
+        Picture **lp = list ? h->long_ref : h->short_ref;
+        int ls = list ? h->long_ref_count : h->short_ref_count;
+
+        for (i = 0; i < ls; ++i) {
+            pic = lp[i];
+            if (!pic || !pic->reference) {
+                continue;
+            }
+            pic_frame_idx = pic->long_ref ? pic->pic_id : pic->frame_num;
+
+            render_ref = (vdpau_render_state_t*)pic->data[2];
+            assert(render_ref != NULL);
+            if (render_ref == NULL)
+                return -1; // make sure that this is render packet
+
+            rf2 = &render->info.h264.referenceFrames[0];
+            while (rf2 != rf) {
+                if (
+                    (rf2->surface == render_ref->surface)
+                    && (rf2->is_long_term == pic->long_ref)
+                    && (rf2->frame_idx == pic_frame_idx)
+                ) {
+                    break;
+                }
+                ++rf2;
+            }
+            if (rf2 != rf) {
+                rf2->top_is_reference |= (pic->reference & PICT_TOP_FIELD) ? VDP_TRUE : VDP_FALSE;
+                rf2->bottom_is_reference |= (pic->reference & PICT_BOTTOM_FIELD) ? VDP_TRUE : VDP_FALSE;
+                continue;
+            }
+
+            if (rf >= &render->info.h264.referenceFrames[H264_RF_COUNT]) {
+                continue;
+            }
+
+            rf->surface             = render_ref->surface;
+            rf->is_long_term        = pic->long_ref;
+            rf->top_is_reference    = (pic->reference & PICT_TOP_FIELD) ? VDP_TRUE : VDP_FALSE;
+            rf->bottom_is_reference = (pic->reference & PICT_BOTTOM_FIELD) ? VDP_TRUE : VDP_FALSE;
+            rf->field_order_cnt[0]  = pic->field_poc[0];
+            rf->field_order_cnt[1]  = pic->field_poc[1];
+            rf->frame_idx           = pic_frame_idx;
+
+            ++rf;
+        }
+    }
+
+    for (; rf < &render->info.h264.referenceFrames[H264_RF_COUNT]; ++rf) {
+        rf->surface             = VDP_INVALID_HANDLE;
+        rf->is_long_term        = 0;
+        rf->top_is_reference    = 0;
+        rf->bottom_is_reference = 0;
+        rf->field_order_cnt[0]  = 0;
+        rf->field_order_cnt[1]  = 0;
+        rf->frame_idx           = 0;
+    }
+
+    return 0;
+}
+
+extern int VDPAU_h264_add_data_chunk(H264Context *h, const uint8_t *buf, int buf_size)
+{
+    MpegEncContext * s = &h->s;
+    vdpau_render_state_t * render;
+
+    render = (vdpau_render_state_t*)s->current_picture_ptr->data[2];
+    assert(render != NULL);
+    assert(render->magic == MP_VDPAU_RENDER_MAGIC);
+    if ((render == NULL) || (render->magic != MP_VDPAU_RENDER_MAGIC))
+        return -1; // make sure that this is render packet
+
+    if (!render->bitstreamBuffersUsed) {
+        VDPAU_h264_set_reference_frames(h);
+    }
+
+    VDPAU_ensure_has_buffers(render, render->bitstreamBuffersUsed + 1);
+
+    render->bitstreamBuffers[render->bitstreamBuffersUsed].struct_version  = VDP_BITSTREAM_BUFFER_VERSION;
+    render->bitstreamBuffers[render->bitstreamBuffersUsed].bitstream       = buf;
+    render->bitstreamBuffers[render->bitstreamBuffersUsed].bitstream_bytes = buf_size;
+    render->bitstreamBuffersUsed++;
+
+    return 0;
+}
+
+int VDPAU_h264_picture_complete(H264Context *h)
+{
+    MpegEncContext * s = &h->s;
+    vdpau_render_state_t * render;
+
+    render = (vdpau_render_state_t*)s->current_picture_ptr->data[2];
+    assert(render != NULL);
+    assert(render->magic == MP_VDPAU_RENDER_MAGIC);
+    if ((render == NULL) || (render->magic != MP_VDPAU_RENDER_MAGIC))
+        return -1; // make sure that this is render packet
+
+    render->info.h264.slice_count = h->slice_num;
+    if (render->info.h264.slice_count < 1)
+        return 0;
+
+    for (int i = 0; i < 2; ++i) {
+        int foc = s->current_picture_ptr->field_poc[i];
+        if (foc == INT_MAX) {
+            foc = 0;
+        }
+        render->info.h264.field_order_cnt[i] = foc;
+    }
+
+    render->info.h264.is_reference                           = s->current_picture_ptr->reference ? VDP_TRUE : VDP_FALSE;
+    render->info.h264.frame_num                              = h->frame_num;
+    render->info.h264.field_pic_flag                         = s->picture_structure != PICT_FRAME;
+    render->info.h264.bottom_field_flag                      = s->picture_structure == PICT_BOTTOM_FIELD;
+    render->info.h264.num_ref_frames                         = h->sps.ref_frame_count;
+    render->info.h264.mb_adaptive_frame_field_flag           = h->sps.mb_aff;
+    render->info.h264.constrained_intra_pred_flag            = h->pps.constrained_intra_pred;
+    render->info.h264.weighted_pred_flag                     = h->pps.weighted_pred;
+    render->info.h264.weighted_bipred_idc                    = h->pps.weighted_bipred_idc;
+    render->info.h264.frame_mbs_only_flag                    = h->sps.frame_mbs_only_flag;
+    render->info.h264.transform_8x8_mode_flag                = h->pps.transform_8x8_mode;
+    render->info.h264.chroma_qp_index_offset                 = h->pps.chroma_qp_index_offset[0];
+    render->info.h264.second_chroma_qp_index_offset          = h->pps.chroma_qp_index_offset[1];
+    render->info.h264.pic_init_qp_minus26                    = h->pps.init_qp - 26;
+    render->info.h264.num_ref_idx_l0_active_minus1           = h->pps.ref_count[0] - 1;
+    render->info.h264.num_ref_idx_l1_active_minus1           = h->pps.ref_count[1] - 1;
+    render->info.h264.log2_max_frame_num_minus4              = h->sps.log2_max_frame_num - 4;
+    render->info.h264.pic_order_cnt_type                     = h->sps.poc_type;
+    render->info.h264.log2_max_pic_order_cnt_lsb_minus4      = h->sps.log2_max_poc_lsb - 4;
+    render->info.h264.delta_pic_order_always_zero_flag       = h->sps.delta_pic_order_always_zero_flag;
+    render->info.h264.direct_8x8_inference_flag              = h->sps.direct_8x8_inference_flag;
+    render->info.h264.entropy_coding_mode_flag               = h->pps.cabac;
+    render->info.h264.pic_order_present_flag                 = h->pps.pic_order_present;
+    render->info.h264.deblocking_filter_control_present_flag = h->pps.deblocking_filter_parameters_present;
+    render->info.h264.redundant_pic_cnt_present_flag = h->pps.redundant_pic_cnt_present;
+    memcpy(render->info.h264.scaling_lists_4x4, h->pps.scaling_matrix4, sizeof(render->info.h264.scaling_lists_4x4));
+    memcpy(render->info.h264.scaling_lists_8x8, h->pps.scaling_matrix8, sizeof(render->info.h264.scaling_lists_8x8));
+
+    ff_draw_horiz_band(s, 0, s->avctx->height);
+    render->bitstreamBuffersUsed = 0;
+
+    return 0;
+}
+
+int VDPAU_vc1_decode_picture(MpegEncContext *s, AVCodecContext *avctx, VC1Context *v, const uint8_t *buf, int buf_size)
+{
+   // VC1Context *v = avctx->priv_data;
+    vdpau_render_state_t * render,* last, * next;
+
+    render = (vdpau_render_state_t*)s->current_picture.data[2];
+    assert(render != NULL);
+    assert(render->magic == MP_VDPAU_RENDER_MAGIC);
+    if ((render == NULL) || (render->magic != MP_VDPAU_RENDER_MAGIC)) {
+        return -1; // make sure that this is render packet
+    }
+    memset(&(render->info), 0 , sizeof(VdpPictureInfoVC1));
+
+    /*  fill LvPictureInfoVC1 struct */
+    render->info.vc1.frame_coding_mode  = v->fcm;
+    render->info.vc1.postprocflag       = v->postprocflag;
+    render->info.vc1.pulldown           = v->broadcast;
+    render->info.vc1.interlace          = v->interlace;
+    render->info.vc1.tfcntrflag         = v->tfcntrflag;
+    render->info.vc1.finterpflag        = v->finterpflag;
+    render->info.vc1.psf                = v->psf;
+    render->info.vc1.dquant             = v->dquant;
+    render->info.vc1.panscan_flag       = v->panscanflag;
+    render->info.vc1.refdist_flag       = v->refdist_flag;
+    render->info.vc1.quantizer          = v->quantizer_mode;
+    render->info.vc1.extended_mv        = v->extended_mv;
+    render->info.vc1.extended_dmv       = v->extended_dmv;
+    render->info.vc1.overlap            = v->overlap;
+    render->info.vc1.vstransform        = v->vstransform;
+    render->info.vc1.loopfilter         = v->s.loop_filter;
+    render->info.vc1.fastuvmc           = v->fastuvmc;
+    render->info.vc1.range_mapy_flag    = v->range_mapy_flag;
+    render->info.vc1.range_mapy         = v->range_mapy;
+    render->info.vc1.range_mapuv_flag   = v->range_mapuv_flag;
+    render->info.vc1.range_mapuv        = v->range_mapuv;
+    /* Specific to simple/main profile only */
+    render->info.vc1.multires           = v->multires;
+    render->info.vc1.syncmarker         = v->s.resync_marker;
+    render->info.vc1.rangered           = v->rangered;
+    render->info.vc1.maxbframes         = v->s.max_b_frames;
+    /* Presently, making these as 0 */
+    render->info.vc1.deblockEnable      = 0;
+    render->info.vc1.pquant             = 0;
+
+    render->info.vc1.forward_reference  = VDP_INVALID_HANDLE;
+    render->info.vc1.backward_reference = VDP_INVALID_HANDLE;
+
+    switch(s->pict_type){
+    case  FF_I_TYPE:
+        render->info.vc1.picture_type = 0;
+        break;
+    case  FF_B_TYPE:
+        if (v->bi_type) {
+            render->info.vc1.picture_type = 4;
+        }
+        else {
+            render->info.vc1.picture_type = 3;
+        }
+        break;
+    case  FF_P_TYPE:
+        render->info.vc1.picture_type = 1;
+        break;
+    case  FF_BI_TYPE:
+        render->info.vc1.picture_type = 4;
+        break;
+    default:
+        return -1;
+    }
+
+    switch(s->pict_type){
+    case  FF_I_TYPE:
+    case  FF_BI_TYPE:
+        break;
+    case  FF_B_TYPE:
+        next = (vdpau_render_state_t*)s->next_picture.data[2];
+        assert(next != NULL);
+        assert(next->magic == MP_VDPAU_RENDER_MAGIC);
+        if ((next == NULL) || (next->magic != MP_VDPAU_RENDER_MAGIC)) {
+            return -1;
+        }
+        render->info.vc1.backward_reference = next->surface;
+        // no break here, going to set forward prediction
+    case  FF_P_TYPE:
+        last = (vdpau_render_state_t*)s->last_picture.data[2];
+        assert(last->magic == MP_VDPAU_RENDER_MAGIC);
+        if (last->magic != MP_VDPAU_RENDER_MAGIC) {
+            return -1;
+        }
+        if (last == NULL) { // FIXME: Does this test make sense?
+            last = render; // predict second field from the first
+        }
+        render->info.vc1.forward_reference = last->surface;
+        break;
+    default:
+        return -1;
+    }
+
+    VDPAU_ensure_has_buffers(render, 1);
+
+    render->bitstreamBuffers[0].struct_version  = VDP_BITSTREAM_BUFFER_VERSION;
+    render->bitstreamBuffers[0].bitstream_bytes = buf_size;
+    render->bitstreamBuffers[0].bitstream       = buf;
+    render->bitstreamBuffersUsed                = 1;
+
+    // FIXME: I am not sure about how MPlayer calculates slice number.
+    render->info.vc1.slice_count                = 1;
+
+    ff_draw_horiz_band(s, 0, s->avctx->height);  
+    render->bitstreamBuffersUsed = 0;
+
+    return 0;
+}
+
+/* @}*/
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/mpegvideo_parser.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/mpegvideo_parser.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/mpegvideo_parser.c	(working copy)
@@ -174,7 +174,9 @@
 }
 
 AVCodecParser mpegvideo_parser = {
-    { CODEC_ID_MPEG1VIDEO, CODEC_ID_MPEG2VIDEO },
+    { CODEC_ID_MPEG1VIDEO,
+      CODEC_ID_MPEG2VIDEO, 
+      CODEC_ID_MPEGVIDEO_VDPAU },
     sizeof(ParseContext1),
     NULL,
     mpegvideo_parse,
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/mpegvideo.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/mpegvideo.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/mpegvideo.c	(working copy)
@@ -58,7 +58,9 @@
 void XVMC_field_end(MpegEncContext *s);
 void XVMC_decode_mb(MpegEncContext *s);
 
+int VDPAU_mpeg_field_start(MpegEncContext *s);
 
+
 /* enable all paranoid tests for rounding, overflows, etc... */
 //#define PARANOID
 
@@ -957,10 +959,12 @@
         XVMC_field_end(s);
     }else
 #endif
-    if(s->unrestricted_mv && s->current_picture.reference && !s->intra_only && !(s->flags&CODEC_FLAG_EMU_EDGE)) {
-            s->dsp.draw_edges(s->current_picture.data[0], s->linesize  , s->h_edge_pos   , s->v_edge_pos   , EDGE_WIDTH  );
-            s->dsp.draw_edges(s->current_picture.data[1], s->uvlinesize, s->h_edge_pos>>1, s->v_edge_pos>>1, EDGE_WIDTH/2);
-            s->dsp.draw_edges(s->current_picture.data[2], s->uvlinesize, s->h_edge_pos>>1, s->v_edge_pos>>1, EDGE_WIDTH/2);
+        if (!s->avctx->vdpau_acceleration) {
+			if (s->unrestricted_mv && s->current_picture.reference && !s->intra_only && !(s->flags&CODEC_FLAG_EMU_EDGE)) {
+				s->dsp.draw_edges(s->current_picture.data[0], s->linesize  , s->h_edge_pos   , s->v_edge_pos   , EDGE_WIDTH  );
+				s->dsp.draw_edges(s->current_picture.data[1], s->uvlinesize, s->h_edge_pos>>1, s->v_edge_pos>>1, EDGE_WIDTH/2);
+				s->dsp.draw_edges(s->current_picture.data[2], s->uvlinesize, s->h_edge_pos>>1, s->v_edge_pos>>1, EDGE_WIDTH/2);
+			}
     }
     emms_c();
 
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/mpeg12.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/mpeg12.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/mpeg12.c	(working copy)
@@ -68,10 +68,22 @@
 void XVMC_pack_pblocks(MpegEncContext *s,int cbp);
 void XVMC_init_block(MpegEncContext *s);//set s->block
 
+int VDPAU_mpeg_field_start(MpegEncContext *s);
+void VDPAU_mpeg_picture_complete(MpegEncContext *s, const uint8_t *buf, int buf_size, int slice_count);
+
 static const enum PixelFormat pixfmt_xvmc_mpg2_420[] = {
                                            PIX_FMT_XVMC_MPEG2_IDCT,
                                            PIX_FMT_XVMC_MPEG2_MC,
                                            PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_mpg1_420[] = {
+                                           PIX_FMT_VDPAU_MPEG1,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_mpg2simple_420[] = {
+                                           PIX_FMT_VDPAU_MPEG2_SIMPLE,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_mpg2main_420[] = {
+                                           PIX_FMT_VDPAU_MPEG2_MAIN,
+                                           PIX_FMT_NONE};
 
 uint8_t ff_mpeg12_static_rl_table_store[2][2][2*MAX_RUN + MAX_LEVEL + 3];
 
@@ -1212,6 +1224,39 @@
     }
 }
 
+static void mpeg_set_pixelformat(AVCodecContext *avctx){
+    Mpeg1Context *s1 = avctx->priv_data;
+    MpegEncContext *s = &s1->mpeg_enc_ctx;
+
+    if(avctx->vdpau_acceleration){
+        if(s->chroma_format >= 2){
+            return -2;
+        }
+        if(avctx->sub_id == 1){
+            avctx->pix_fmt = avctx->get_format(avctx,pixfmt_vdpau_mpg1_420);
+        }else{
+            if(avctx->profile == 5){
+                avctx->pix_fmt = avctx->get_format(avctx,pixfmt_vdpau_mpg2simple_420);
+            }else if(avctx->profile == 4){
+                avctx->pix_fmt = avctx->get_format(avctx,pixfmt_vdpau_mpg2main_420);
+            }else{
+                return -2;
+            }
+        }
+    }else if(avctx->xvmc_acceleration){
+        avctx->pix_fmt = avctx->get_format(avctx,pixfmt_xvmc_mpg2_420);
+    }else{
+        if(s->chroma_format <  2){
+            avctx->pix_fmt = PIX_FMT_YUV420P; //avctx->get_format(avctx,pixfmt_yuv_420);
+        }else if(s->chroma_format == 2){
+            avctx->pix_fmt = PIX_FMT_YUV422P; //avctx->get_format(avctx,pixfmt_yuv_422);
+        }else if(s->chroma_format >  2){
+            avctx->pix_fmt = PIX_FMT_YUV444P; //avctx->get_format(avctx,pixfmt_yuv_444);
+        }
+    }
+}    
+
+
 /* Call this function when we know all parameters.
  * It may be called in different places for MPEG-1 and MPEG-2. */
 static int mpeg_decode_postinit(AVCodecContext *avctx){
@@ -1288,23 +1333,14 @@
             }
         }//MPEG-2
 
-        if(avctx->xvmc_acceleration){
-            avctx->pix_fmt = avctx->get_format(avctx,pixfmt_xvmc_mpg2_420);
-        }else{
-            if(s->chroma_format <  2){
-                avctx->pix_fmt = PIX_FMT_YUV420P;
-            }else
-            if(s->chroma_format == 2){
-                avctx->pix_fmt = PIX_FMT_YUV422P;
-            }else
-            if(s->chroma_format >  2){
-                avctx->pix_fmt = PIX_FMT_YUV444P;
-            }
-        }
+        mpeg_set_pixelformat(avctx);
+
         //until then pix_fmt may be changed right after codec init
         if( avctx->pix_fmt == PIX_FMT_XVMC_MPEG2_IDCT )
             if( avctx->idct_algo == FF_IDCT_AUTO )
                 avctx->idct_algo = FF_IDCT_SIMPLE;
+        if (avctx->vdpau_acceleration)
+            avctx->idct_algo = FF_IDCT_SIMPLE;
 
         /* Quantization matrices may need reordering
          * if DCT permutation is changed. */
@@ -1646,6 +1682,9 @@
          XVMC_field_start(s,avctx);
 #endif
 
+    if (s->avctx->vdpau_acceleration)
+        VDPAU_mpeg_field_start(s);
+
     return 0;
 }
 
@@ -1922,7 +1961,8 @@
 
         s->current_picture_ptr->qscale_type= FF_QSCALE_TYPE_MPEG2;
 
-        ff_er_frame_end(s);
+        if (!s->avctx->vdpau_acceleration)
+            ff_er_frame_end(s);
 
         MPV_frame_end(s);
 
@@ -2069,15 +2109,13 @@
     avctx->has_b_frames= 0; //true?
     s->low_delay= 1;
 
-    if(avctx->xvmc_acceleration){
-        avctx->pix_fmt = avctx->get_format(avctx,pixfmt_xvmc_mpg2_420);
-    }else{
-        avctx->pix_fmt = PIX_FMT_YUV420P;
-    }
+    mpeg_set_pixelformat(avctx);
 
     if( avctx->pix_fmt == PIX_FMT_XVMC_MPEG2_IDCT )
         if( avctx->idct_algo == FF_IDCT_AUTO )
             avctx->idct_algo = FF_IDCT_SIMPLE;
+    if (avctx->vdpau_acceleration)
+        avctx->idct_algo = FF_IDCT_SIMPLE;
 
     if (MPV_common_init(s) < 0)
         return -1;
@@ -2303,6 +2341,10 @@
                     for(i=0; i<s->slice_count; i++)
                         s2->error_count += s2->thread_context[i]->error_count;
                 }
+                if (avctx->vdpau_acceleration) {
+                    /* Fills mpeg12 picture informations before returing from libavcodec. */
+                    VDPAU_mpeg_picture_complete(s2, buf, buf_size, s->slice_count);
+                }
                 if (slice_end(avctx, picture)) {
                     if(s2->last_picture_ptr || s2->low_delay) //FIXME merge with the stuff in mpeg_decode_slice
                         *data_size = sizeof(AVPicture);
@@ -2388,6 +2430,11 @@
                     return -1;
                 }
 
+                if (avctx->vdpau_acceleration) {
+                    s->slice_count++;
+                    break;                
+                }
+
                 if(avctx->thread_count > 1){
                     int threshold= (s2->mb_height*s->slice_count + avctx->thread_count/2) / avctx->thread_count;
                     if(threshold <= mb_y){
@@ -2507,3 +2554,34 @@
 };
 
 #endif
+#if ENABLE_MPEG_VDPAU_DECODER
+static av_cold int mpeg_vdpau_decode_init(AVCodecContext *avctx){
+    if( avctx->thread_count > 1)
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_CODED_ORDER) )
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD) ){
+        dprintf(avctx, "mpeg12.c: VDPAU decoder does not set SLICE_FLAG_ALLOW_FIELD\n");
+    }
+    avctx->vdpau_acceleration = 1;
+    mpeg_decode_init(avctx);
+    // Set in mpeg_decode_postinit() later
+    avctx->pix_fmt = PIX_FMT_NONE;
+
+    return 0;
+}
+
+AVCodec mpeg_vdpau_decoder = {
+    "mpegvideo_vdpau",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_MPEGVIDEO_VDPAU,
+    sizeof(Mpeg1Context),
+    mpeg_vdpau_decode_init,
+    NULL,
+    mpeg_decode_end,
+    mpeg_decode_frame,
+    CODEC_CAP_DR1 | CODEC_CAP_TRUNCATED | CODEC_CAP_HWACCEL_VDPAU | CODEC_CAP_DELAY,
+    .flush= ff_mpeg_flush,
+    .long_name = NULL_IF_CONFIG_SMALL("MPEG-1/2 video (VDPAU acceleration)"),
+};
+#endif
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h263dec.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h263dec.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h263dec.c	(working copy)
@@ -92,6 +92,8 @@
         break;
     case CODEC_ID_VC1:
     case CODEC_ID_WMV3:
+    case CODEC_ID_VC1_VDPAU:
+    case CODEC_ID_WMV3_VDPAU:
         s->h263_msmpeg4 = 1;
         s->h263_pred = 1;
         s->msmpeg4_version=6;
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/allcodecs.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/allcodecs.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/allcodecs.c	(working copy)
@@ -87,6 +87,7 @@
     REGISTER_ENCDEC  (H263, h263);
     REGISTER_DECODER (H263I, h263i);
     REGISTER_ENCODER (H263P, h263p);
+    REGISTER_DECODER (H264, h264_vdpau);
     REGISTER_DECODER (H264, h264);
     REGISTER_ENCDEC  (HUFFYUV, huffyuv);
     REGISTER_DECODER (IDCIN, idcin);
@@ -104,6 +105,7 @@
     REGISTER_DECODER (MMVIDEO, mmvideo);
     REGISTER_DECODER (MOTIONPIXELS, motionpixels);
     REGISTER_DECODER (MPEG_XVMC, mpeg_xvmc);
+    REGISTER_DECODER (MPEG_VDPAU, mpeg_vdpau);
     REGISTER_ENCDEC  (MPEG1VIDEO, mpeg1video);
     REGISTER_ENCDEC  (MPEG2VIDEO, mpeg2video);
     REGISTER_ENCDEC  (MPEG4, mpeg4);
@@ -154,6 +156,7 @@
     REGISTER_DECODER (ULTI, ulti);
     REGISTER_DECODER (VB, vb);
     REGISTER_DECODER (VC1, vc1);
+    REGISTER_DECODER (VC1_VDPAU, vc1_vdpau);
     REGISTER_DECODER (VCR1, vcr1);
     REGISTER_DECODER (VMDVIDEO, vmdvideo);
     REGISTER_DECODER (VMNC, vmnc);
@@ -166,6 +169,7 @@
     REGISTER_ENCDEC  (WMV1, wmv1);
     REGISTER_ENCDEC  (WMV2, wmv2);
     REGISTER_DECODER (WMV3, wmv3);
+	REGISTER_DECODER (WMV3_VDPAU, wmv3_vdpau);
     REGISTER_DECODER (WNV1, wnv1);
     REGISTER_DECODER (XAN_WC3, xan_wc3);
     REGISTER_DECODER (XL, xl);
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vdpau_render.h
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vdpau_render.h	(revision 0)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vdpau_render.h	(revision 0)
@@ -0,0 +1,93 @@
+/*
+ * Video Decode and Presentation API for UNIX (VDPAU) is used for
+ * HW decode acceleration for MPEG-1/2, H.264 and VC-1.
+ *
+ * Copyright (C) 2008 NVIDIA.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFMPEG_VDPAU_RENDER_H
+#define FFMPEG_VDPAU_RENDER_H
+
+/**
+ * \defgroup Decoder VDPAU Decoder and Renderer
+ *
+ * VDPAU HW acceleration has two modules
+ * - VDPAU Decoding
+ * - VDPAU Presentation
+ *
+ * VDPAU decoding module parses all headers using MPlayer
+ * parsing mechanism and uses VDPAU for the actual decoding.
+ *
+ * As per the current implementation, the actual decoding 
+ * and rendering (API calls) are done as part of VDPAU
+ * presentation (vo_vdpau.c) module.
+ *
+ * @{
+ * \defgroup  VDPAU_Decoding VDPAU Decoding
+ * \ingroup Decoder
+ * @{
+ */
+
+#include "vdpau/vdpau.h"
+#include "vdpau/vdpau_x11.h"
+
+/**
+ * \brief The videoSurface is used for render.
+ */
+#define MP_VDPAU_STATE_USED_FOR_RENDER 1
+
+/**
+ * \brief The videoSurface is needed for reference/prediction,
+ * codec manipulates this.
+ */
+#define MP_VDPAU_STATE_USED_FOR_REFERENCE 2
+
+#define MP_VDPAU_RENDER_MAGIC 0x1DC8E14B
+
+/** 
+ * \brief This structure is used as a CALL-BACK between the ffmpeg 
+ * decoder (vd_) and presentation (vo_) module.
+ * This is used for defining a video-frame containing surface,
+ * picture-parameter, bitstream informations etc which are passed 
+ * between ffmpeg decoder and its clients.
+ */
+typedef struct {
+    int  magic;
+
+    VdpVideoSurface surface; /** used as rendered surface, never changed.*/
+
+    int state; /** Holds MP_VDPAU_STATE_* values */
+
+    /** Picture Parameter information for all supported codecs */
+    union _VdpPictureInfo {
+        VdpPictureInfoMPEG1Or2 mpeg;
+        VdpPictureInfoH264     h264;
+        VdpPictureInfoVC1       vc1;
+    } info;
+
+    /** Describe size/location of the compressed video data */
+    int bitstreamBuffersAlloced;
+    int bitstreamBuffersUsed;
+    VdpBitstreamBuffer *bitstreamBuffers;
+} vdpau_render_state_t;
+
+/* @}*/
+/* @}*/
+
+#endif /* FFMPEG_VDPAU_RENDER_H */
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/avcodec.h
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/avcodec.h	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/avcodec.h	(working copy)
@@ -190,6 +190,10 @@
     CODEC_ID_MOTIONPIXELS,
     CODEC_ID_TGV,
     CODEC_ID_TGQ,
+    CODEC_ID_MPEGVIDEO_VDPAU,
+    CODEC_ID_H264_VDPAU,
+    CODEC_ID_VC1_VDPAU,
+    CODEC_ID_WMV3_VDPAU,
 
     /* various PCM "codecs" */
     CODEC_ID_PCM_S16LE= 0x10000,
@@ -526,6 +530,10 @@
  * This can be used to prevent truncation of the last audio samples.
  */
 #define CODEC_CAP_SMALL_LAST_FRAME 0x0040
+/**
+ * Codec can export data for HW decoding (VDPAU). 
+ */
+#define CODEC_CAP_HWACCEL_VDPAU    0x0080
 
 //The following defines may change, don't expect compatibility if you use them.
 #define MB_TYPE_INTRA4x4   0x0001
@@ -2286,6 +2294,13 @@
     int64_t request_channel_layout;
 
     /**
+     * VDPAU Acceleration
+     * - encoding: forbidden
+     * - decoding: set by decoder
+     */
+    int vdpau_acceleration;
+
+    /**
      * Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.
      * - encoding: Set by user.
      * - decoding: unused.
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/imgconvert.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/imgconvert.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/imgconvert.c	(working copy)
@@ -267,6 +267,33 @@
     [PIX_FMT_XVMC_MPEG2_IDCT] = {
         .name = "xvmcidct",
     },
+    [PIX_FMT_VDPAU_MPEG1] = {
+        .name = "vdpau_mpeg1",
+    },
+    [PIX_FMT_VDPAU_MPEG2_SIMPLE] = {
+        .name = "vdpau_mpeg2_simple",
+    },
+    [PIX_FMT_VDPAU_MPEG2_MAIN] = {
+        .name = "vdpau_mpeg2_main",
+    },
+    [PIX_FMT_VDPAU_H264_BASELINE] = {
+        .name = "vdpau_h264_baseline",
+    },
+    [PIX_FMT_VDPAU_H264_MAIN] = {
+        .name = "vdpau_h264_main",
+    },
+    [PIX_FMT_VDPAU_H264_HIGH] = {
+        .name = "vdpau_h264_high",
+    },
+    [PIX_FMT_VDPAU_VC1_SIMPLE] = {
+        .name = "vdpau_vc1_simple",
+    },
+    [PIX_FMT_VDPAU_VC1_MAIN] = {
+        .name = "vdpau_vc1_main",
+    },
+    [PIX_FMT_VDPAU_VC1_ADVANCED] = {
+        .name = "vdpau_vc1_advanced",
+    },
     [PIX_FMT_UYYVYY411] = {
         .name = "uyyvyy411",
         .nb_channels = 1,
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vc1.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vc1.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vc1.c	(working copy)
@@ -41,8 +41,22 @@
 #define MB_INTRA_VLC_BITS 9
 #define DC_VLC_BITS 9
 #define AC_VLC_BITS 9
+
+int VDPAU_vc1_decode_picture(MpegEncContext *s, AVCodecContext *avctx, VC1Context *v, const uint8_t *buf, int buf_size);
+
 static const uint16_t table_mb_intra[64][2];
 
+#if (ENABLE_VC1_VDPAU_DECODER || ENABLE_WMV3_VDPAU_DECODER)
+static const enum PixelFormat pixfmt_vdpau_vc1_simple_420[] = {
+                                           PIX_FMT_VDPAU_VC1_SIMPLE,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_vc1_main_420[] = {
+                                           PIX_FMT_VDPAU_VC1_MAIN,
+                                           PIX_FMT_NONE};
+static const enum PixelFormat pixfmt_vdpau_vc1_advanced_420[] = {
+                                           PIX_FMT_VDPAU_VC1_ADVANCED,
+                                           PIX_FMT_NONE};
+#endif
 
 /**
  * Init VC-1 specific tables and VC1Context members
@@ -828,6 +842,23 @@
     }
 }
 
+#if (ENABLE_VC1_VDPAU_DECODER || ENABLE_WMV3_VDPAU_DECODER)
+static int decode_postinit(VC1Context *v, AVCodecContext *avctx)
+{
+    if (v->profile == 0) {
+        avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_vc1_simple_420);
+    } else if (v->profile == 1) {
+        avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_vc1_main_420);
+    } else if (v->profile == 3) {
+        avctx->pix_fmt = avctx->get_format(avctx, pixfmt_vdpau_vc1_advanced_420);
+    } else {
+        return -2;
+    }            
+
+    return 0;
+}
+#endif
+
 static int decode_sequence_header_adv(VC1Context *v, GetBitContext *gb);
 
 /**
@@ -1007,8 +1038,24 @@
     if(get_bits1(gb)) { //Display Info - decoding is not affected by it
         int w, h, ar = 0;
         av_log(v->s.avctx, AV_LOG_DEBUG, "Display extended info:\n");
-        v->s.avctx->width  = v->s.width  = w = get_bits(gb, 14) + 1;
-        v->s.avctx->height = v->s.height = h = get_bits(gb, 14) + 1;
+        // FIXME: The w/h parsed here are the *display* width/height, not the
+        // coded width/height. Ideally, we should make the commented
+        // assignments below, but that causes problems:
+        // * The SW decoder in this file experiences errors, because it
+        //   assumes these assigned values are the coded size:
+        //   [vc1 @ 0x86f2130]concealing 150 DC, 150 AC, 150 MV errors
+        // * VDPAU also assumes these are the coded size, since this is the
+        //   only size passed to vo_vdpau.c:config(). This causes errors
+        //   during the decode process.
+        // However, simply removing these assignments is not the complete fix,
+        // because without them, the stream is displayed at its coded size,
+        // not this requested display size. Ideally, setting:
+        // sample_aspect_ratio = (AVRational){w, h}
+        // in the case when ar is not present/set would persuade other modules
+        // to scale to this requested size. However, sample_aspect_ratio
+        // appears to be completely ignored elsewhere.
+        /*v->s.avctx->width  = v->s.width  =*/ w = get_bits(gb, 14) + 1;
+        /*v->s.avctx->height = v->s.height =*/ h = get_bits(gb, 14) + 1;
         av_log(v->s.avctx, AV_LOG_DEBUG, "Display dimensions: %ix%i\n", w, h);
         if(get_bits1(gb))
             ar = get_bits(gb, 4);
@@ -1059,14 +1106,14 @@
 static int decode_entry_point(AVCodecContext *avctx, GetBitContext *gb)
 {
     VC1Context *v = avctx->priv_data;
-    int i, blink, clentry, refdist;
+    int i, blink, clentry;
 
     av_log(avctx, AV_LOG_DEBUG, "Entry point: %08X\n", show_bits_long(gb, 32));
     blink = get_bits1(gb); // broken link
     clentry = get_bits1(gb); // closed entry
     v->panscanflag = get_bits1(gb);
-    refdist = get_bits1(gb); // refdist flag
-    v->s.loop_filter = get_bits1(gb);
+    v->refdist_flag = get_bits1(gb);
+	v->s.loop_filter = get_bits1(gb);
     v->fastuvmc = get_bits1(gb);
     v->extended_mv = get_bits1(gb);
     v->dquant = get_bits(gb, 2);
@@ -1086,20 +1133,22 @@
     }
     if(v->extended_mv)
         v->extended_dmv = get_bits1(gb);
-    if(get_bits1(gb)) {
+    v->range_mapy_flag = get_bits1(gb);
+    if(v->range_mapy_flag) {
         av_log(avctx, AV_LOG_ERROR, "Luma scaling is not supported, expect wrong picture\n");
-        skip_bits(gb, 3); // Y range, ignored for now
+        v->range_mapy = get_bits(gb, 3);
     }
-    if(get_bits1(gb)) {
+    v->range_mapuv_flag = get_bits1(gb);
+    if(v->range_mapuv_flag) {
         av_log(avctx, AV_LOG_ERROR, "Chroma scaling is not supported, expect wrong picture\n");
-        skip_bits(gb, 3); // UV range, ignored for now
+        v->range_mapuv = get_bits(gb, 3);
     }
 
     av_log(avctx, AV_LOG_DEBUG, "Entry point info:\n"
         "BrokenLink=%i, ClosedEntry=%i, PanscanFlag=%i\n"
         "RefDist=%i, Postproc=%i, FastUVMC=%i, ExtMV=%i\n"
         "DQuant=%i, VSTransform=%i, Overlap=%i, Qmode=%i\n",
-        blink, clentry, v->panscanflag, refdist, v->s.loop_filter,
+        blink, clentry, v->panscanflag, v->refdist_flag, v->s.loop_filter,
         v->fastuvmc, v->extended_mv, v->dquant, v->vstransform, v->overlap, v->quantizer_mode);
 
     return 0;
@@ -1399,6 +1448,9 @@
 
     if(v->s.pict_type == FF_I_TYPE || v->s.pict_type == FF_P_TYPE) v->use_ic = 0;
 
+    if(v->postprocflag)
+        v->postproc = get_bits(gb, 2);
+
     switch(v->s.pict_type) {
     case FF_I_TYPE:
     case FF_BI_TYPE:
@@ -3996,7 +4048,7 @@
 
     avctx->coded_width = avctx->width;
     avctx->coded_height = avctx->height;
-    if (avctx->codec_id == CODEC_ID_WMV3)
+    if ((avctx->codec_id == CODEC_ID_WMV3) || (avctx->codec_id == CODEC_ID_WMV3_VDPAU))
     {
         int count = 0;
 
@@ -4111,6 +4163,7 @@
     MpegEncContext *s = &v->s;
     AVFrame *pict = data;
     uint8_t *buf2 = NULL;
+    const uint8_t *buf_vdpau = buf;
 
     /* no supplementary picture */
     if (buf_size == 0) {
@@ -4132,6 +4185,10 @@
         s->current_picture_ptr= &s->picture[i];
     }
 
+	// pxt_fmt calculation for VDPAU.
+    if (avctx->vdpau_acceleration && (avctx->pix_fmt == PIX_FMT_NONE) && (decode_postinit(v, avctx) < 0))
+        return -1;
+
     //for advanced profile we may need to parse and unescape data
     if (avctx->codec_id == CODEC_ID_VC1) {
         int buf_size2 = 0;
@@ -4148,6 +4205,8 @@
                 if(size <= 0) continue;
                 switch(AV_RB32(start)){
                 case VC1_CODE_FRAME:
+                    if (avctx->vdpau_acceleration)
+                        buf_vdpau = start;
                     buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);
                     break;
                 case VC1_CODE_ENTRYPOINT: /* it should be before frame data */
@@ -4233,17 +4292,30 @@
         return -1;
     }
 
+    // MPV_frame_start() calls to  get_buffer/videoSurfaces. Now we call
+    // VDPAU_vc1_field_start where picture-parameters are filled.
+    // VDPAU_vc1_picture_complete calls to vdpau_decoder_render.
+
+    if (avctx->vdpau_acceleration) {
+        if (VDPAU_vc1_decode_picture(s, avctx, v, buf_vdpau, (buf + buf_size) - buf_vdpau) < 0) {
+            av_free(buf2);
+            return -1;
+        }
+    }
+
     s->me.qpel_put= s->dsp.put_qpel_pixels_tab;
     s->me.qpel_avg= s->dsp.avg_qpel_pixels_tab;
 
-    ff_er_frame_start(s);
+    if (!avctx->vdpau_acceleration) {
+        ff_er_frame_start(s);
 
-    v->bits = buf_size * 8;
-    vc1_decode_blocks(v);
+        v->bits = buf_size * 8;
+        vc1_decode_blocks(v);
 //av_log(s->avctx, AV_LOG_INFO, "Consumed %i/%i bits\n", get_bits_count(&s->gb), buf_size*8);
 //  if(get_bits_count(&s->gb) > buf_size * 8)
 //      return -1;
-    ff_er_frame_end(s);
+        ff_er_frame_end(s);
+	}
 
     MPV_frame_end(s);
 
@@ -4317,3 +4389,53 @@
     NULL,
     .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 9"),
 };
+
+#if (ENABLE_VC1_VDPAU_DECODER || ENABLE_WMV3_VDPAU_DECODER)
+static av_cold int vc1_vdpau_decode_init(AVCodecContext *avctx){
+    if( avctx->thread_count > 1)
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_CODED_ORDER) )
+        return -1;
+    if( !(avctx->slice_flags & SLICE_FLAG_ALLOW_FIELD) ){
+        dprintf(avctx, "vc1.c: VDPAU decoder does not set SLICE_FLAG_ALLOW_FIELD\n");
+    }
+    avctx->vdpau_acceleration = 1;
+    vc1_decode_init(avctx);
+    // Set in decode_postinit() later
+    avctx->pix_fmt = PIX_FMT_NONE;
+
+    return 0;
+}
+#endif
+
+#if ENABLE_WMV3_VDPAU_DECODER
+AVCodec wmv3_vdpau_decoder = {
+    "wmv3_vdpau",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_WMV3_VDPAU,
+    sizeof(VC1Context),
+    vc1_vdpau_decode_init,
+    NULL,
+    vc1_decode_end,
+    vc1_decode_frame,
+    CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,
+    NULL,
+    .long_name = NULL_IF_CONFIG_SMALL("Windows Media Video 9 VDPAU"),
+};
+#endif
+
+#if ENABLE_VC1_VDPAU_DECODER
+AVCodec vc1_vdpau_decoder = {
+    "vc1_vdpau",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_VC1_VDPAU,
+    sizeof(VC1Context),
+    vc1_vdpau_decode_init,
+    NULL,
+    vc1_decode_end,
+    vc1_decode_frame,
+    CODEC_CAP_DR1 | CODEC_CAP_DELAY | CODEC_CAP_HWACCEL_VDPAU,
+    NULL,
+    .long_name = NULL_IF_CONFIG_SMALL("SMPTE VC-1 VDPAU"),
+};
+#endif
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vc1.h
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vc1.h	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/vc1.h	(working copy)
@@ -180,6 +180,7 @@
     int interlace;        ///< Progressive/interlaced (RPTFTM syntax element)
     int tfcntrflag;       ///< TFCNTR present
     int panscanflag;      ///< NUMPANSCANWIN, TOPLEFT{X,Y}, BOTRIGHT{X,Y} present
+    int refdist_flag;     ///< REFDIST syntax element present in II, IP, PI or PP field picture headers
     int extended_dmv;     ///< Additional extended dmv range at P/B frame-level
     int color_prim;       ///< 8bits, chroma coordinates of the color primaries
     int transfer_char;    ///< 8bits, Opto-electronic transfer characteristics
Index: XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h264_parser.c
===================================================================
--- XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h264_parser.c	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/Codecs/ffmpeg/libavcodec/h264_parser.c	(working copy)
@@ -161,7 +161,8 @@
 
 
 AVCodecParser h264_parser = {
-    { CODEC_ID_H264 },
+    { CODEC_ID_H264,
+      CODEC_ID_H264_VDPAU },
     sizeof(H264Context),
     NULL,
     h264_parse,
Index: XBMC/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
===================================================================
--- XBMC/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	(working copy)
@@ -116,7 +116,8 @@
   InitializeCriticalSection(&m_critCodecSection);
   m_messageQueue.SetMaxDataSize(20 * 256 * 1024); 
   g_dvdPerformanceCounter.EnableVideoQueue(&m_messageQueue);
-  
+  firstFrame = true;
+
   m_iCurrentPts = DVD_NOPTS_VALUE;
   m_iDroppedFrames = 0;
   m_bDropFrames = true;
@@ -457,6 +458,7 @@
 
             if(picture.iDuration == 0)
               picture.iDuration = frametime;
+              CLog::Log(LOGNOTICE,"frametime %f", frametime);
 
             if(bPacketDrop)
               picture.iFlags |= DVP_FLAG_DROPPED;
@@ -470,6 +472,7 @@
             /* try to figure out a pts for this frame */
             if(picture.pts == DVD_NOPTS_VALUE && pPacket->dts != DVD_NOPTS_VALUE)
               picture.pts = pPacket->dts;
+              CLog::Log(LOGNOTICE,"picture.pts %f", picture.pts);
 
             /* use forced aspect if any */
             if( m_fForcedAspectRatio != 0.0f )
@@ -740,6 +743,10 @@
 
 int CDVDPlayerVideo::OutputPicture(DVDVideoPicture* pPicture, double pts)
 {
+  if (firstFrame) {
+    
+  }
+  CLog::Log(LOGNOTICE,"OutputPictue pts = %f",pts);
   /* check so that our format or aspect has changed. if it has, reconfigure renderer */
   if (m_output.width != pPicture->iWidth
    || m_output.height != pPicture->iHeight
@@ -918,7 +925,6 @@
     Sleep(1);
     index = g_renderManager.GetImage(&image);
   }
-
   if (index < 0) 
     return EOS_DROPPED;
 
Index: XBMC/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
===================================================================
--- XBMC/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	(working copy)
@@ -128,11 +128,29 @@
   { // non halfres mode, we can use other decoders
     if (hint.codec == CODEC_ID_MPEG2VIDEO || hint.codec == CODEC_ID_MPEG1VIDEO)
     {
+#ifdef HAVE_VDPAU
       CDVDCodecOptions dvdOptions;
+      CLog::Log(LOGNOTICE,"Trying VDPAU-MPEG from FFMPEG");
+      hint.codec = CODEC_ID_MPEGVIDEO_VDPAU;
+      if( (pCodec = OpenCodec(new CDVDVideoCodecFFmpeg(), hint, dvdOptions)) ) return pCodec;
+#else
+      CDVDCodecOptions dvdOptions;
       if( (pCodec = OpenCodec(new CDVDVideoCodecLibMpeg2(), hint, dvdOptions)) ) return pCodec;
+#endif
     }
+    if (hint.codec == CODEC_ID_H264)
+    {
+#ifdef HAVE_VDPAU
+      CDVDCodecOptions dvdOptions;
+      CLog::Log(LOGNOTICE,"Trying VDPAU-H264 from FFMPEG");
+      hint.codec = CODEC_ID_H264_VDPAU;
+      if( (pCodec = OpenCodec(new CDVDVideoCodecFFmpeg(), hint, dvdOptions)) ) return pCodec;
+#else
+      CDVDCodecOptions dvdOptions;
+      if( (pCodec = OpenCodec(new CDVDVideoCodecFFmpeg(), hint, dvdOptions)) ) return pCodec;
+#endif
+    }
   }
-
   CDVDCodecOptions dvdOptions;
   if( (pCodec = OpenCodec(new CDVDVideoCodecFFmpeg(), hint, dvdOptions)) ) return pCodec;
 
Index: XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
===================================================================
--- XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp	(working copy)
@@ -38,6 +38,14 @@
 #define RINT lrint
 #endif
 
+#include "Surface.h"
+using namespace Surface;
+extern bool usingVDPAU;
+extern CDVDVideoCodecVDPAU* m_VDPAU;
+#include "cores/VideoRenderers/RenderManager.h"
+
+#define ARSIZE(x) (sizeof(x) / sizeof((x)[0]))
+
 int my_get_buffer(struct AVCodecContext *c, AVFrame *pic){
     if (c->pix_fmt == PIX_FMT_NONE)
       return -1;
@@ -49,7 +57,7 @@
 }
 
 void my_release_buffer(struct AVCodecContext *c, AVFrame *pic){
-    if(pic) 
+    if(pic)
     {
       free(pic->opaque);
       pic->opaque = NULL;
@@ -57,15 +65,16 @@
     ((CDVDVideoCodecFFmpeg*)c->opaque)->m_dllAvCodec.avcodec_default_release_buffer(c, pic);
 }
 
-
 CDVDVideoCodecFFmpeg::CDVDVideoCodecFFmpeg() : CDVDVideoCodec()
 {
+  CLog::Log(LOGNOTICE,"Constructing CDVDVideoCodecFFmpeg");
   m_pCodecContext = NULL;
   m_pConvertFrame = NULL;
   m_pFrame = NULL;
 
   m_iPictureWidth = 0;
   m_iPictureHeight = 0;
+  usingVDPAU = false;
 
   m_iScreenWidth = 0;
   m_iScreenHeight = 0;
@@ -73,11 +82,21 @@
 
 CDVDVideoCodecFFmpeg::~CDVDVideoCodecFFmpeg()
 {
+  if (m_VDPAU) {
+    delete m_VDPAU;
+    m_VDPAU = NULL;
+  }
+  if (m_Surface) {
+    CLog::Log(LOGNOTICE,"Deleting m_Surface in CDVDVideoCodecFFmpeg");
+    delete m_Surface;
+    m_Surface = NULL;
+  }
   Dispose();
 }
 
 bool CDVDVideoCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
+  CLog::Log(LOGNOTICE,"CDVDVideoCodecFFmpeg::Open");
   AVCodec* pCodec;
 
   if (!m_dllAvUtil.Load() || !m_dllAvCodec.Load() || !m_dllSwScale.Load()) return false;
@@ -93,11 +112,25 @@
     CLog::Log(LOGDEBUG,"CDVDVideoCodecFFmpeg::Open() Unable to find codec %d", hints.codec);
     return false;
   }
+  CLog::Log(LOGNOTICE,"Using codec: %s",pCodec->long_name);
 
   m_pCodecContext->opaque = (void*)this;
   m_pCodecContext->get_buffer = my_get_buffer;
   m_pCodecContext->release_buffer = my_release_buffer;
-
+#ifdef HAVE_VDPAU
+  if(pCodec->capabilities & CODEC_CAP_HWACCEL_VDPAU){
+    if (!m_Surface) m_Surface = new CSurface(g_graphicsContext.getScreenSurface());
+    m_Surface->MakePixmap(hints.width,hints.height);
+    Pixmap px = m_Surface->GetXPixmap();
+    m_VDPAU = new CDVDVideoCodecVDPAU(g_graphicsContext.getScreenSurface()->GetDisplay(), px);
+    m_pCodecContext->get_format= CDVDVideoCodecVDPAU::VDPAUGetFormat;
+    m_pCodecContext->get_buffer= CDVDVideoCodecVDPAU::VDPAUGetBuffer;
+    m_pCodecContext->release_buffer= CDVDVideoCodecVDPAU::VDPAUReleaseBuffer;
+    m_pCodecContext->draw_horiz_band = CDVDVideoCodecVDPAU::VDPAURenderFrame;
+    usingVDPAU = true;
+  }
+#endif
+  m_pCodecContext->slice_flags=SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
   m_pCodecContext->debug_mv = 0;
   m_pCodecContext->debug = 0;
   m_pCodecContext->workaround_bugs = FF_BUG_AUTODETECT;
@@ -105,7 +138,6 @@
    * first frame. setting to -1 avoid enabling DR1 for them.
    */
   m_pCodecContext->pix_fmt = (PixelFormat) - 1;  
-
   if (pCodec->id != CODEC_ID_H264 && pCodec->capabilities & CODEC_CAP_DR1)
     m_pCodecContext->flags |= CODEC_FLAG_EMU_EDGE;
 
@@ -148,21 +180,17 @@
     m_dllAvCodec.av_set_string(m_pCodecContext, it->m_name.c_str(), it->m_value.c_str());
   }
 
-#if defined(_LINUX) || defined(_WIN32PC)
-  int num_threads = std::min(8 /*MAX_THREADS*/, g_cpuInfo.getCPUCount());
-  if(num_threads > 1 && (pCodec->id == CODEC_ID_H264 || pCodec->id == CODEC_ID_MPEG4 || pCodec->id == CODEC_ID_MPEG2VIDEO))
-    m_dllAvCodec.avcodec_thread_init(m_pCodecContext, num_threads);
-#endif
-
   if (m_dllAvCodec.avcodec_open(m_pCodecContext, pCodec) < 0)
   {
     CLog::Log(LOGDEBUG,"CDVDVideoCodecFFmpeg::Open() Unable to open codec");
     return false;
   }
-
+  CLog::Log(LOGNOTICE,"CDVDVideoCodecFFmpeg::Open() Using VDPAU %i",m_pCodecContext->vdpau_acceleration);
   m_pFrame = m_dllAvCodec.avcodec_alloc_frame();
-  if (!m_pFrame) return false;
-
+  if (!m_pFrame) {
+	  CLog::Log(LOGERROR,"CDVDVideoCodecFFmpeg::Open() Failed to allocate frames");
+	  return false;
+  }
   return true;
 }
 
@@ -229,7 +257,6 @@
 int CDVDVideoCodecFFmpeg::Decode(BYTE* pData, int iSize, double pts)
 {
   int iGotPicture = 0, len = 0;
-
   if (!m_pCodecContext) 
     return VC_ERROR;
 
@@ -260,8 +287,13 @@
     return VC_BUFFER;
 
   if (m_pCodecContext->pix_fmt != PIX_FMT_YUV420P
-   && m_pCodecContext->pix_fmt != PIX_FMT_YUVJ420P)
+      && m_pCodecContext->pix_fmt != PIX_FMT_YUVJ420P
+#ifdef HAVE_VDPAU
+      && !(m_VDPAU->isVDPAUFormat(m_pCodecContext->pix_fmt))
+#endif
+      )
   {
+    CLog::Log(LOGERROR, "%s - unsupported format - attempting to convert pix_fmt %i", __FUNCTION__,m_pCodecContext->pix_fmt);
     if (!m_dllSwScale.IsLoaded())
     {
       if(!m_dllSwScale.Load())
@@ -347,32 +379,32 @@
 bool CDVDVideoCodecFFmpeg::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
   GetVideoAspect(m_pCodecContext, pDvdVideoPicture->iDisplayWidth, pDvdVideoPicture->iDisplayHeight);
-
   pDvdVideoPicture->iWidth = m_pCodecContext->width;
   pDvdVideoPicture->iHeight = m_pCodecContext->height;
   pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
-
-  // if we have a converted frame, use that
+  
   AVFrame *frame = m_pConvertFrame ? m_pConvertFrame : m_pFrame;
-
   if (!frame)
     return false;
   
-  for (int i = 0; i < 4; i++) pDvdVideoPicture->data[i] = frame->data[i];
-  for (int i = 0; i < 4; i++) pDvdVideoPicture->iLineSize[i] = frame->linesize[i];
+  for (int i = 0; i < 3; i++) pDvdVideoPicture->data[i] = frame->data[i];
+  for (int i = 0; i < 3; i++) pDvdVideoPicture->iLineSize[i] = frame->linesize[i];
   pDvdVideoPicture->iRepeatPicture = frame->repeat_pict;
-  pDvdVideoPicture->iFlags = DVP_FLAG_ALLOCATED;    
+  pDvdVideoPicture->iFlags = DVP_FLAG_ALLOCATED;
   pDvdVideoPicture->iFlags |= frame->interlaced_frame ? DVP_FLAG_INTERLACED : 0;
   pDvdVideoPicture->iFlags |= frame->top_field_first ? DVP_FLAG_TOP_FIELD_FIRST: 0;
   pDvdVideoPicture->iFlags |= frame->data[0] ? 0 : DVP_FLAG_DROPPED;
-  if(m_pCodecContext->pix_fmt == PIX_FMT_YUVJ420P)
+  if (m_pCodecContext->pix_fmt == PIX_FMT_YUVJ420P)
     pDvdVideoPicture->color_range = 1;
-
-  if(frame->opaque)
-    pDvdVideoPicture->pts = *(double*)frame->opaque;
-  else
+  
+  if (frame->opaque) {
+    //pDvdVideoPicture->pts = *(double*)frame->opaque;
+    CLog::Log(LOGNOTICE,"%%VDPAU%% PTS=%f",pDvdVideoPicture->pts);
+  }
+  else {
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
-
+    CLog::Log(LOGNOTICE,"%%VDPAU%% using DVD_NOPTS");
+  }
   return true;
 }
 
Index: XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpegVDPAU.cpp
===================================================================
--- XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpegVDPAU.cpp	(revision 0)
+++ XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpegVDPAU.cpp	(revision 0)
@@ -0,0 +1,726 @@
+/*
+ *  DVDVideoCodecFFmpegVDPAU.cpp
+ *  XBMC
+ *
+ *  Created by David Allonby on 10/02/2009.
+ *  Copyright 2009 __MyCompanyName__. All rights reserved.
+ *
+ */
+
+#include "DVDVideoCodecFFmpegVDPAU.h"
+#include "Surface.h"
+using namespace Surface;
+
+#include "vdpau_render.h"
+#include "TextureManager.h"                         //DAVID-CHECKNEEDED
+#include "cores/VideoRenderers/RenderManager.h"
+#include "DVDVideoCodecFFmpeg.h"
+
+#define ARSIZE(x) (sizeof(x) / sizeof((x)[0]))
+
+static CDVDVideoCodecVDPAU *pSingleton = NULL;
+
+
+CDVDVideoCodecVDPAU::CDVDVideoCodecVDPAU(Display* display, Pixmap px)
+{
+  // Point the singleton to myself so we can use it to access our
+  // instance variables from our static callbacks
+  pSingleton = this;
+  surfaceNum = 0;
+  m_Pixmap = px;
+  b_age = ip_age[0] = ip_age[1] = 256*256*256*64;
+  m_Display=display;
+  vdpauConfigured = false;
+  initVDPAUProcs();
+  initVDPAUOutput();
+  outputSurface = 0;
+  lastFrameTime = nextFrameTime = 0;
+}
+
+CDVDVideoCodecVDPAU::~CDVDVideoCodecVDPAU()
+{
+  finiVDPAUOutput();
+  finiVDPAUProcs();
+	if (num_video_surfaces)
+    free(videoSurfaces);
+  pSingleton = NULL;
+}
+
+bool CDVDVideoCodecVDPAU::isVDPAUFormat(uint32_t format)
+{
+	if ((format >= PIX_FMT_VDPAU_MPEG1) && (format <= PIX_FMT_VDPAU_VC1_ADVANCED)) return true;
+	else return false;
+}
+
+void CDVDVideoCodecVDPAU::initVDPAUProcs()
+{
+  int mScreen = DefaultScreen(g_graphicsContext.getScreenSurface()->GetDisplay());
+  VdpStatus vdp_st;
+  
+  // Create Device
+  vdp_st = vdp_device_create_x11(g_graphicsContext.getScreenSurface()->GetDisplay(), //x_display,
+                                 mScreen, //x_screen,
+                                 &vdp_device,
+                                 &vdp_get_proc_address);
+	CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(vdp_device,
+                                VDP_FUNC_ID_DEVICE_DESTROY,
+                                (void **)&vdp_device_destroy);
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(vdp_device,
+                                VDP_FUNC_ID_VIDEO_SURFACE_CREATE,
+                                (void **)&vdp_video_surface_create);
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_VIDEO_SURFACE_DESTROY,
+                                (void **)&vdp_video_surface_destroy
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_VIDEO_SURFACE_PUT_BITS_Y_CB_CR,
+                                (void **)&vdp_video_surface_put_bits_y_cb_cr
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR,
+                                (void **)&vdp_video_surface_get_bits_y_cb_cr
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_Y_CB_CR,
+                                (void **)&vdp_output_surface_put_bits_y_cb_cr
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_NATIVE,
+                                (void **)&vdp_output_surface_put_bits_native
+                                );
+  CHECK_ST
+  
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_OUTPUT_SURFACE_CREATE,
+                                (void **)&vdp_output_surface_create
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_OUTPUT_SURFACE_DESTROY,
+                                (void **)&vdp_output_surface_destroy
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_OUTPUT_SURFACE_GET_BITS_NATIVE,
+                                (void **)&vdp_output_surface_get_bits_native
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_VIDEO_MIXER_CREATE,
+                                (void **)&vdp_video_mixer_create
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_VIDEO_MIXER_SET_FEATURE_ENABLES,
+                                (void **)&vdp_video_mixer_set_feature_enables
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_VIDEO_MIXER_DESTROY,
+                                (void **)&vdp_video_mixer_destroy
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_VIDEO_MIXER_RENDER,
+                                (void **)&vdp_video_mixer_render
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_GENERATE_CSC_MATRIX,
+                                (void **)&vdp_generate_csc_matrix
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_VIDEO_MIXER_SET_ATTRIBUTE_VALUES,
+                                (void **)&vdp_video_mixer_set_attribute_values
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_DESTROY,
+                                (void **)&vdp_presentation_queue_target_destroy
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_PRESENTATION_QUEUE_CREATE,
+                                (void **)&vdp_presentation_queue_create
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_PRESENTATION_QUEUE_DESTROY,
+                                (void **)&vdp_presentation_queue_destroy
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_PRESENTATION_QUEUE_DISPLAY,
+                                (void **)&vdp_presentation_queue_display
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_PRESENTATION_QUEUE_BLOCK_UNTIL_SURFACE_IDLE,
+                                (void **)&vdp_presentation_queue_block_until_surface_idle
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_CREATE_X11,
+                                (void **)&vdp_presentation_queue_target_create_x11
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_DECODER_CREATE,
+                                (void **)&vdp_decoder_create
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_DECODER_DESTROY,
+                                (void **)&vdp_decoder_destroy
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_DECODER_RENDER,
+                                (void **)&vdp_decoder_render
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_PRESENTATION_QUEUE_QUERY_SURFACE_STATUS,
+                                (void **)&vdp_presentation_queue_query_surface_status
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_PRESENTATION_QUEUE_GET_TIME,
+                                (void **)&vdp_presentation_queue_get_time
+                                );
+  CHECK_ST
+  
+  // Added for draw_osd.
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_OUTPUT_SURFACE_RENDER_OUTPUT_SURFACE,
+                                (void **)&vdp_output_surface_render_output_surface
+                                );
+  CHECK_ST
+  
+  vdp_st = vdp_get_proc_address(
+                                vdp_device,
+                                VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_INDEXED,
+                                (void **)&vdp_output_surface_put_bits_indexed
+                                );
+  CHECK_ST
+  
+}
+
+VdpStatus CDVDVideoCodecVDPAU::finiVDPAUProcs()
+{
+  VdpStatus vdp_st;
+  
+  vdp_st = vdp_device_destroy(vdp_device);
+  CHECK_ST
+  
+  return VDP_STATUS_OK;
+}
+
+void CDVDVideoCodecVDPAU::initVDPAUOutput()
+{
+  VdpStatus vdp_st;
+  vdp_st = vdp_presentation_queue_target_create_x11(vdp_device,
+                                                    m_Pixmap, //x_window,
+                                                    &vdp_flip_target);
+  CHECK_ST
+  
+  vdp_st = vdp_presentation_queue_create(vdp_device,
+                                         vdp_flip_target,
+                                         &vdp_flip_queue);
+  CHECK_ST
+}
+
+VdpStatus CDVDVideoCodecVDPAU::finiVDPAUOutput()
+{
+  VdpStatus vdp_st;
+  
+  vdp_st = vdp_presentation_queue_destroy(vdp_flip_queue);
+  CHECK_ST
+  
+  vdp_st = vdp_presentation_queue_target_destroy(vdp_flip_target);
+  CHECK_ST
+  
+  return VDP_STATUS_OK;
+}
+
+
+int CDVDVideoCodecVDPAU::configVDPAU(uint32_t width, uint32_t height,
+                                     uint32_t format)
+{
+  if (vdpauConfigured) return 1;
+  VdpStatus vdp_st;
+  int i;
+  VdpDecoderProfile vdp_decoder_profile;
+  VdpChromaType vdp_chroma_type;
+  uint32_t max_references;
+  image_format = format;
+  
+  // FIXME: Are higher profiles able to decode all lower profile streams?
+  switch (format) {
+    case PIX_FMT_VDPAU_MPEG1:
+      vdp_decoder_profile = VDP_DECODER_PROFILE_MPEG1;
+      vdp_chroma_type = VDP_CHROMA_TYPE_420;
+      num_video_surfaces = NUM_VIDEO_SURFACES_MPEG2;
+      break;
+    case PIX_FMT_VDPAU_MPEG2_SIMPLE:
+      vdp_decoder_profile = VDP_DECODER_PROFILE_MPEG2_SIMPLE;
+      vdp_chroma_type = VDP_CHROMA_TYPE_420;
+      num_video_surfaces = NUM_VIDEO_SURFACES_MPEG2;
+      break;
+    case PIX_FMT_VDPAU_MPEG2_MAIN:
+      vdp_decoder_profile = VDP_DECODER_PROFILE_MPEG2_MAIN;
+      vdp_chroma_type = VDP_CHROMA_TYPE_420;
+      num_video_surfaces = NUM_VIDEO_SURFACES_MPEG2;
+      break;
+    case PIX_FMT_VDPAU_H264_BASELINE:
+      vdp_decoder_profile = VDP_DECODER_PROFILE_H264_BASELINE;
+      vdp_chroma_type = VDP_CHROMA_TYPE_420;
+      // Theoretically, "num_reference_surfaces+1" is correct.
+      // However, to work around invalid/corrupt streams,
+      // and/or ffmpeg DPB management issues,
+      // we allocate more than we should need to allow problematic
+      // streams to play.
+      //num_video_surfaces = num_reference_surfaces + 1;
+      num_video_surfaces = NUM_VIDEO_SURFACES_H264;
+      break;
+    case PIX_FMT_VDPAU_H264_MAIN:
+      vdp_decoder_profile = VDP_DECODER_PROFILE_H264_MAIN;
+      vdp_chroma_type = VDP_CHROMA_TYPE_420;
+      // Theoretically, "num_reference_surfaces+1" is correct.
+      // However, to work around invalid/corrupt streams,
+      // and/or ffmpeg DPB management issues,
+      // we allocate more than we should need to allow problematic
+      // streams to play.
+      //num_video_surfaces = num_reference_surfaces + 1;
+      num_video_surfaces = NUM_VIDEO_SURFACES_H264;
+      break;
+    case PIX_FMT_VDPAU_H264_HIGH:
+      vdp_decoder_profile = VDP_DECODER_PROFILE_H264_HIGH;
+      vdp_chroma_type = VDP_CHROMA_TYPE_420;
+      // Theoretically, "num_reference_surfaces+1" is correct.
+      // However, to work around invalid/corrupt streams,
+      // and/or ffmpeg DPB management issues,
+      // we allocate more than we should need to allow problematic
+      // streams to play.
+      //num_video_surfaces = num_reference_surfaces + 1;
+      num_video_surfaces = NUM_VIDEO_SURFACES_H264;
+      break;
+    case PIX_FMT_VDPAU_VC1_SIMPLE:
+      vdp_decoder_profile = VDP_DECODER_PROFILE_VC1_SIMPLE;
+      vdp_chroma_type = VDP_CHROMA_TYPE_420;
+      num_video_surfaces = NUM_VIDEO_SURFACES_VC1;
+      break;
+    case PIX_FMT_VDPAU_VC1_MAIN:
+      vdp_decoder_profile = VDP_DECODER_PROFILE_VC1_MAIN;
+      vdp_chroma_type = VDP_CHROMA_TYPE_420;
+      num_video_surfaces = NUM_VIDEO_SURFACES_VC1;
+      break;
+    case PIX_FMT_VDPAU_VC1_ADVANCED:
+      vdp_decoder_profile = VDP_DECODER_PROFILE_VC1_ADVANCED;
+      vdp_chroma_type = VDP_CHROMA_TYPE_420;
+      num_video_surfaces = NUM_VIDEO_SURFACES_VC1;
+      break;
+      
+      /* Non VDPAU specific formats.
+       * No HW acceleration. VdpDecoder will not be created and 
+       * there will be no call for VdpDecoderRender.
+       */
+      /*case PIX_FMT_YV12:
+       vdp_chroma_type = VDP_CHROMA_TYPE_420;
+       num_video_surfaces = NUM_VIDEO_SURFACES_NON_ACCEL_YUV;
+       break;*/
+    case PIX_FMT_BGRA:
+      // No need for videoSurfaces, directly renders to outputSurface.
+      num_video_surfaces = NUM_VIDEO_SURFACES_NON_ACCEL_RGB;
+      break;
+    default:
+      assert(0);
+      return 1;
+  }
+  
+	if (num_video_surfaces) {
+    videoSurfaces = (VdpVideoSurface *)malloc(sizeof(VdpVideoSurface)*num_video_surfaces);
+  } else {
+    videoSurfaces = NULL;
+  }
+  
+  switch (format) {
+    case PIX_FMT_VDPAU_H264_MAIN:
+    case PIX_FMT_VDPAU_H264_HIGH:
+   {
+     // FIXME: Use "h->sps.ref_frame_count" here instead.
+     
+     // Level 4.1 limits:
+     uint32_t round_width = (width + 15) & ~15;
+     uint32_t round_height = (height + 15) & ~15;
+     //            uint32_t surf_size = (round_width * round_height * 3) / 2;
+     max_references = 16;
+     if (max_references > 16) {
+       max_references = 16;
+     }
+   }
+      break;
+    default:
+      max_references = 2;
+      break;
+  }
+  
+  if (isVDPAUFormat(image_format)) {
+    vdp_st = vdp_decoder_create(vdp_device,
+                                vdp_decoder_profile,
+                                width,
+                                height,
+                                max_references,
+                                &decoder);
+    CHECK_ST
+  }
+  
+  // Creation of VideoSurfaces
+  for (i = 0; i < num_video_surfaces; i++) {
+    vdp_st = vdp_video_surface_create(vdp_device,
+                                      vdp_chroma_type,
+                                      width,
+                                      height,
+                                      &videoSurfaces[i]);
+    CHECK_ST
+  }
+  
+  if (num_video_surfaces) {
+    surface_render = (vdpau_render_state_t*)malloc(num_video_surfaces*sizeof(vdpau_render_state_t));
+    memset(surface_render,0,num_video_surfaces*sizeof(vdpau_render_state_t));
+    
+    for (i = 0; i < num_video_surfaces; i++) {
+      surface_render[i].magic = MP_VDPAU_RENDER_MAGIC;
+      surface_render[i].state = MP_VDPAU_STATE_USED_FOR_RENDER;
+      surface_render[i].surface = videoSurfaces[i];
+    }
+    
+    // Creation of VideoMixer.
+    VdpVideoMixerParameter parameters[] = {
+      VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH,
+      VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT,
+      VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE
+    };
+    
+    void const * parameter_values[] = {
+      &width,
+      &height,
+      &vdp_chroma_type
+    };
+    
+    vdp_st = vdp_video_mixer_create(vdp_device,
+                                    0,
+                                    NULL,
+                                    ARSIZE(parameters),
+                                    parameters,
+                                    parameter_values,
+                                    &videoMixer);
+    CHECK_ST
+  } else {
+    surface_render = NULL;
+  }
+  
+  // Creation of outputSurfaces
+  for (i = 0; i < NUM_OUTPUT_SURFACES; i++) {
+    vdp_st = vdp_output_surface_create(vdp_device,
+                                       VDP_RGBA_FORMAT_B8G8R8A8,
+                                       width,
+                                       height,
+                                       &outputSurfaces[i]);
+    CHECK_ST
+  }
+  surfaceNum = 0;
+  outputSurface = outputSurfaces[surfaceNum];
+  
+  outRectVid.x0 = 0;
+  outRectVid.y0 = 0;
+  outRectVid.x1 = width;
+  outRectVid.y1 = height;
+  
+  outRect.x0 = 0;
+  outRect.x1 = width;
+  outRect.y0 = 0;
+  outRect.y1 = height;
+  
+  videoSurface = videoSurfaces[0];
+  
+  vdp_st = vdp_video_mixer_render(videoMixer,
+                                  VDP_INVALID_HANDLE,
+                                  0,
+                                  VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
+                                  0,
+                                  NULL,
+                                  videoSurface,
+                                  0,
+                                  NULL,
+                                  NULL,
+                                  outputSurface,
+                                  &outRect,
+                                  &outRectVid,
+                                  0,
+                                  NULL);
+  CHECK_ST
+  vdpauConfigured = true;
+  return 0;
+}
+
+enum PixelFormat CDVDVideoCodecVDPAU::VDPAUGetFormat(struct AVCodecContext * avctx,
+                                                     const PixelFormat * fmt)
+{
+  if(avctx->vdpau_acceleration){
+    avctx->get_buffer= VDPAUGetBuffer;
+    avctx->release_buffer= VDPAUReleaseBuffer;
+    avctx->draw_horiz_band = VDPAURenderFrame;
+    avctx->slice_flags=SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
+  }
+  pSingleton->configVDPAU(avctx->width,avctx->height,fmt[0]);
+  return fmt[0];
+}
+
+vdpau_render_state_t * CDVDVideoCodecVDPAU::VDPAUFindFreeSurface()
+{
+  int i; 
+  for (i = 0 ; i < pSingleton->num_video_surfaces; i++)
+   {
+     //CLog::Log(LOGDEBUG,"find_free_surface(%i):0x%08x @ 0x%08x",i,pSingleton->surface_render[i].state, &(pSingleton->surface_render[i]));
+     if (!(pSingleton->surface_render[i].state & MP_VDPAU_STATE_USED_FOR_REFERENCE)) {
+       return &(pSingleton->surface_render[i]);
+     }
+   }
+  return NULL;
+}
+
+int CDVDVideoCodecVDPAU::VDPAUGetBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+  pSingleton->configVDPAU(avctx->width,avctx->height,avctx->pix_fmt);
+  vdpau_render_state_t * render;
+  
+  if(!avctx->vdpau_acceleration){
+    CLog::Log(LOGERROR,"vdpau_get_buffer() How did we get here?!");
+    assert(0);
+    exit(1);
+  }
+  
+  assert(avctx->draw_horiz_band == VDPAURenderFrame);
+  assert(avctx->release_buffer == VDPAUReleaseBuffer);
+  
+  if(!pic->reference){
+    pSingleton->b_count++;
+  }else{
+    pSingleton->ip_count++;
+  }
+  
+  render = VDPAUFindFreeSurface();
+	assert(render->magic == MP_VDPAU_RENDER_MAGIC);
+	render->state = 0;
+  
+  pic->data[0]= (uint8_t*)render;
+  pic->data[1]= (uint8_t*)render;
+  pic->data[2]= (uint8_t*)render;
+  
+  /* Note, some (many) codecs in libavcodec must have stride1==stride2 && no changes between frames
+   * lavc will check that and die with an error message, if its not true
+   */
+  pic->linesize[0]= 0;
+  pic->linesize[1]= 0;
+  pic->linesize[2]= 0;
+  
+  double *pts= (double*)malloc(sizeof(double));
+  *pts= ((CDVDVideoCodecFFmpeg*)avctx->opaque)->m_pts;
+  pic->opaque= pts;
+
+   
+  if(pic->reference)
+   {   //I or P frame
+     pic->age= pSingleton->ip_age[0];
+     pSingleton->ip_age[0]= pSingleton->ip_age[1]+1;
+     pSingleton->ip_age[1]= 1;
+     pSingleton->b_age++;
+   } else
+    {   //B frame
+      pic->age= pSingleton->b_age;
+      pSingleton->ip_age[0]++;
+      pSingleton->ip_age[1]++;
+      pSingleton->b_age=1;
+    }
+  
+  pic->type= FF_BUFFER_TYPE_USER;
+  
+  assert(render != NULL);
+  assert(render->magic == MP_VDPAU_RENDER_MAGIC);
+  render->state |= MP_VDPAU_STATE_USED_FOR_REFERENCE;
+  
+  return 0;
+}
+
+void CDVDVideoCodecVDPAU::VDPAUReleaseBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+  vdpau_render_state_t * render;
+  int i;
+  
+  if(pSingleton->ip_count <= 2 && pSingleton->b_count<=1){
+    if(pic->reference)
+      pSingleton->ip_count--;
+    else
+      pSingleton->b_count--;
+  }
+  
+  // Mark the surface as not required for prediction
+  render=(vdpau_render_state_t*)pic->data[2];
+  assert(render != NULL);
+  assert(render->magic == MP_VDPAU_RENDER_MAGIC);
+  render->state &= ~MP_VDPAU_STATE_USED_FOR_REFERENCE;
+  for(i=0; i<4; i++){
+    pic->data[i]= NULL;
+  }
+  if (pic->opaque)
+    free(pic->opaque);
+  pic->opaque = NULL;
+}
+
+int CDVDVideoCodecVDPAU::VDPAUDrawSlice(uint8_t * image[], int stride[], int w, int h,
+                                        int x, int y)
+{
+  VdpStatus vdp_st;
+  vdpau_render_state_t * render;
+  
+  render = (vdpau_render_state_t*)image[2]; // this is a copy of private
+  assert( render != NULL );
+  assert(render->magic == MP_VDPAU_RENDER_MAGIC);
+  pSingleton->videoSurface = render->surface;
+  
+  /* VdpDecoderRender is called with decoding order. Decoded images are store in
+   * videoSurface like rndr->surface. VdpVideoMixerRender put this videoSurface
+   * to outputSurface which is displayable.
+   */
+  vdp_st = pSingleton->vdp_decoder_render(pSingleton->decoder,
+                                          pSingleton->videoSurface,
+                                          (VdpPictureInfo const *)&(render->info),
+                                          render->bitstreamBuffersUsed,
+                                          render->bitstreamBuffers);
+  CHECK_ST
+  return 0;
+}
+
+
+void CDVDVideoCodecVDPAU::VDPAURenderFrame(struct AVCodecContext *s,
+                                           const AVFrame *src, int offset[4],
+                                           int y, int type, int height)
+{
+  VdpStatus vdp_st;
+
+  int width= s->width;
+  uint8_t *source[3]= {src->data[0], src->data[1], src->data[2]};
+
+  assert(src->linesize[0]==0 && src->linesize[1]==0 && src->linesize[2]==0);
+  assert(offset[0]==0 && offset[1]==0 && offset[2]==0);
+
+  pSingleton->VDPAUDrawSlice(source, (int*)(src->linesize), width, height, 0, y);
+}
+
+void CDVDVideoCodecVDPAU::VDPAUPrePresent()
+{
+  VdpTime dummy;
+  VdpStatus vdp_st;
+
+  pSingleton->outputSurface = pSingleton->outputSurfaces[pSingleton->surfaceNum];
+  usleep(2000);
+  vdp_st = pSingleton->vdp_presentation_queue_block_until_surface_idle(
+                                             pSingleton->vdp_flip_queue,
+                                             pSingleton->outputSurface,
+                                             &dummy);
+  CHECK_ST
+  vdp_st = pSingleton->vdp_video_mixer_render(pSingleton->videoMixer,
+                                              VDP_INVALID_HANDLE,
+                                              0,
+                                              VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME,
+                                              0,
+                                              NULL,
+                                              pSingleton->videoSurface,
+                                              0,
+                                              NULL,
+                                              NULL,
+                                              pSingleton->outputSurface,
+                                              &(pSingleton->outRect),
+                                              &(pSingleton->outRectVid),
+                                              0,
+                                              NULL);
+  CHECK_ST
+}
+
+void CDVDVideoCodecVDPAU::VDPAUPresent()
+{
+  VdpTime time;
+  VdpStatus vdp_st;
+
+  VdpPresentationQueueStatus status;
+
+  vdp_st = pSingleton->vdp_presentation_queue_get_time(pSingleton->vdp_flip_queue, &time);
+  vdp_st = pSingleton->vdp_presentation_queue_display(pSingleton->vdp_flip_queue,
+                                                      pSingleton->outputSurface,
+                                                      FFMAX(pSingleton->outRect.x1, pSingleton->outRectVid.x1),
+                                                      FFMAX(pSingleton->outRect.y1, pSingleton->outRectVid.y1),
+                                                      time); 
+  pSingleton->surfaceNum = pSingleton->surfaceNum ^ 1;
+}
Index: XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
===================================================================
--- XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h	(working copy)
@@ -1,5 +1,6 @@
 #pragma once
-
+#ifndef __DVDVIDEOCODECFFMMPEG_H
+#define __DVDVIDEOCODECFFMMPEG_H
 /*
  *      Copyright (C) 2005-2008 Team XBMC
  *      http://www.xbmc.org
@@ -21,11 +22,16 @@
  *
  */
 
+#define HAVE_VDPAU 1
+
 #include "DVDVideoCodec.h"
 #include "cores/ffmpeg/DllAvCodec.h"
 #include "cores/ffmpeg/DllAvFormat.h"
 #include "cores/ffmpeg/DllSwScale.h"
+#include "DVDVideoCodecFFmpegVDPAU.h"
 
+extern CDVDVideoCodecVDPAU* m_VDPAU;
+
 class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
 {
 public:
@@ -38,6 +44,7 @@
   virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture);
   virtual void SetDropState(bool bDrop);
   virtual const char* GetName() { return "FFmpeg"; };
+  double m_pts;
 
 protected:
   friend int my_get_buffer(struct AVCodecContext *, AVFrame *);
@@ -47,7 +54,7 @@
 
   AVFrame* m_pFrame;
   AVCodecContext* m_pCodecContext;
-
+  
   AVFrame* m_pConvertFrame;
 
   int m_iPictureWidth;
@@ -56,10 +63,11 @@
   int m_iScreenWidth;
   int m_iScreenHeight;
 
-  double m_pts;
-
   DllAvCodec m_dllAvCodec;
   DllAvUtil  m_dllAvUtil;
   DllSwScale m_dllSwScale;
 };
 
+#endif  //__DVDVIDEOCODECFFMMPEG_H
+
+
Index: XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile
===================================================================
--- XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile	(working copy)
@@ -2,7 +2,8 @@
 
 SRCS=	DVDVideoCodecFFmpeg.cpp \
 	DVDVideoCodecLibMpeg2.cpp \
-	DVDVideoPPFFmpeg.cpp
+	DVDVideoPPFFmpeg.cpp \
+        DVDVideoCodecFFmpegVDPAU.cpp
 
 LIB=Video.a
 
Index: XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpegVDPAU.h
===================================================================
--- XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpegVDPAU.h	(revision 0)
+++ XBMC/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpegVDPAU.h	(revision 0)
@@ -0,0 +1,142 @@
+#pragma once
+#ifndef __DVDVIDEOCODECFFMMPEGVDPAU_H
+#define __DVDVIDEOCODECFFMMPEGVDPAU_H
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "stdafx.h"
+#include "DVDVideoCodec.h"
+#include "cores/ffmpeg/DllAvCodec.h"
+#include "cores/ffmpeg/DllAvFormat.h"
+#include "cores/ffmpeg/DllSwScale.h"
+#include "cores/ffmpeg/vdpau_render.h"
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#define GL_GLEXT_PROTOTYPES
+#define GLX_GLXEXT_PROTOTYPES
+#include <GL/gl.h>
+#include <GL/glx.h>
+
+#define CHECK_ST \
+if (vdp_st != VDP_STATUS_OK) \
+CLog::Log(LOGERROR, " (VDPAU) Error %d at %s:%d\n", vdp_st, __FILE__, __LINE__); \
+  //else CLog::Log(LOGNOTICE, " (VDPAU) Success at %s:%d\n", __FILE__, __LINE__);
+
+
+#define CHECK_GL \
+rv = glGetError(); \
+if (rv) \
+CLog::Log(LOGERROR, "openGL Error: %i",rv);
+
+#define NUM_OUTPUT_SURFACES                4
+#define NUM_VIDEO_SURFACES_MPEG2           3  // (1 frame being decoded, 2 reference)
+#define NUM_VIDEO_SURFACES_H264            32 // (1 frame being decoded, up to 16 references) 
+#define NUM_VIDEO_SURFACES_VC1             3  // (same as MPEG-2)
+#define NUM_VIDEO_SURFACES_NON_ACCEL_YUV   1  //  surfaces for YV12 etc. 
+#define NUM_VIDEO_SURFACES_NON_ACCEL_RGB   0 // surfaces for RGB or YUV4:4:4
+#define PALETTE_SIZE 256
+
+
+class CDVDVideoCodecVDPAU {
+public:
+  static void VDPAUReleaseBuffer(AVCodecContext *avctx, AVFrame *pic);
+  static void VDPAURenderFrame(struct AVCodecContext *s,
+                               const AVFrame *src, int offset[4],
+                               int y, int type, int height);
+  static enum PixelFormat VDPAUGetFormat(struct AVCodecContext * avctx,
+                                         const enum PixelFormat * pix_fmt);
+  static int VDPAUGetBuffer(AVCodecContext *avctx, AVFrame *pic);  
+  static vdpau_render_state_t * VDPAUFindFreeSurface();
+  static int VDPAUDrawSlice(uint8_t * image[],
+                            int stride[], 
+                            int w, int h,
+                            int x, int y);
+  static void VDPAUPrePresent();
+  static void VDPAUPresent();
+  CDVDVideoCodecVDPAU(Display* display, Pixmap px);
+  virtual ~CDVDVideoCodecVDPAU();
+  virtual bool isVDPAUFormat(uint32_t format);
+  int configVDPAU(uint32_t width, uint32_t height,
+                  uint32_t format);
+  VdpTime lastFrameTime, nextFrameTime;
+  
+  //  protected:
+  virtual void initVDPAUProcs();
+  virtual VdpStatus finiVDPAUProcs();
+  virtual void initVDPAUOutput();
+  virtual VdpStatus finiVDPAUOutput();  
+  VdpDevice           vdp_device;
+  VdpGetProcAddress * vdp_get_proc_address;
+  VdpPresentationQueueTarget vdp_flip_target;
+  VdpPresentationQueue       vdp_flip_queue;
+  VdpDeviceDestroy * vdp_device_destroy;
+  VdpVideoSurfaceCreate * vdp_video_surface_create;
+  VdpVideoSurfaceDestroy * vdp_video_surface_destroy;
+  VdpVideoSurfacePutBitsYCbCr * vdp_video_surface_put_bits_y_cb_cr;
+  VdpVideoSurfaceGetBitsYCbCr * vdp_video_surface_get_bits_y_cb_cr;
+  VdpOutputSurfacePutBitsYCbCr * vdp_output_surface_put_bits_y_cb_cr;
+  VdpOutputSurfacePutBitsNative * vdp_output_surface_put_bits_native;
+  VdpOutputSurfaceCreate * vdp_output_surface_create;
+  VdpOutputSurfaceDestroy * vdp_output_surface_destroy;
+  VdpOutputSurfaceGetBitsNative * vdp_output_surface_get_bits_native;
+  VdpVideoMixerCreate * vdp_video_mixer_create;
+  VdpVideoMixerSetFeatureEnables * vdp_video_mixer_set_feature_enables;
+  VdpVideoMixerDestroy * vdp_video_mixer_destroy;
+  VdpVideoMixerRender * vdp_video_mixer_render;
+  VdpGenerateCSCMatrix * vdp_generate_csc_matrix;
+  VdpVideoMixerSetAttributeValues * vdp_video_mixer_set_attribute_values;  
+  VdpPresentationQueueTargetDestroy * vdp_presentation_queue_target_destroy;
+  VdpPresentationQueueCreate * vdp_presentation_queue_create;
+  VdpPresentationQueueDestroy * vdp_presentation_queue_destroy;
+  VdpPresentationQueueDisplay * vdp_presentation_queue_display;
+  VdpPresentationQueueBlockUntilSurfaceIdle * vdp_presentation_queue_block_until_surface_idle;
+  VdpPresentationQueueTargetCreateX11 * vdp_presentation_queue_target_create_x11;
+  VdpPresentationQueueQuerySurfaceStatus * vdp_presentation_queue_query_surface_status;
+  VdpPresentationQueueGetTime * vdp_presentation_queue_get_time;
+  VdpOutputSurfaceRenderOutputSurface * vdp_output_surface_render_output_surface;
+  VdpOutputSurfacePutBitsIndexed * vdp_output_surface_put_bits_indexed;
+  VdpDecoderCreate * vdp_decoder_create;
+  VdpDecoderDestroy * vdp_decoder_destroy;
+  VdpDecoderRender * vdp_decoder_render;
+  VdpVideoSurface *videoSurfaces;
+  VdpOutputSurface outputSurfaces[NUM_OUTPUT_SURFACES];
+  VdpVideoSurface videoSurface;
+  VdpOutputSurface outputSurface;
+  VdpDecoder decoder;
+  VdpVideoMixer videoMixer;
+  VdpRect outRect;
+  VdpRect outRectVid;
+  vdpau_render_state_t * surface_render;
+  int surfaceNum;
+  uint32_t vid_width, vid_height;
+  uint32_t image_format;
+  uint32_t num_video_surfaces;
+  uint32_t num_reference_surfaces;
+  int ip_age[2];
+  int b_age, ip_count, b_count;
+  GLenum rv;
+  Display* m_Display;
+  Pixmap m_Pixmap;
+  bool vdpauConfigured;
+};
+
+#endif // __DVDVIDEOCODECFFMMPEGVDPAU_H
Index: XBMC/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp
===================================================================
--- XBMC/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/DVDCodecs/DVDCodecUtils.cpp	(working copy)
@@ -18,6 +18,7 @@
  *  http://www.gnu.org/copyleft/gpl.html
  *
  */
+
  
 #include "stdafx.h"
 #include "DVDCodecUtils.h"
Index: XBMC/xbmc/cores/dvdplayer/DVDPlayerVideo.h
===================================================================
--- XBMC/xbmc/cores/dvdplayer/DVDPlayerVideo.h	(revision 17697)
+++ XBMC/xbmc/cores/dvdplayer/DVDPlayerVideo.h	(working copy)
@@ -112,6 +112,7 @@
 #define EOS_DROPPED 2
 #define EOS_VERYLATE 4
 
+  bool firstFrame;
   int OutputPicture(DVDVideoPicture* pPicture, double pts);
   void ProcessOverlays(DVDVideoPicture* pSource, YV12Image* pDest, double pts);
   void ProcessVideoUserData(DVDVideoUserData* pVideoUserData, double pts);
Index: XBMC/xbmc/cores/ffmpeg/avutil.h
===================================================================
--- XBMC/xbmc/cores/ffmpeg/avutil.h	(revision 17697)
+++ XBMC/xbmc/cores/ffmpeg/avutil.h	(working copy)
@@ -121,6 +121,15 @@
     PIX_FMT_YUV440P,   ///< Planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
     PIX_FMT_YUVJ440P,  ///< Planar YUV 4:4:0 full scale (jpeg)
     PIX_FMT_YUVA420P,  ///< Planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
+    PIX_FMT_VDPAU_MPEG1,
+    PIX_FMT_VDPAU_MPEG2_SIMPLE,
+    PIX_FMT_VDPAU_MPEG2_MAIN,
+    PIX_FMT_VDPAU_H264_BASELINE,
+    PIX_FMT_VDPAU_H264_MAIN,
+    PIX_FMT_VDPAU_H264_HIGH,
+    PIX_FMT_VDPAU_VC1_SIMPLE,
+    PIX_FMT_VDPAU_VC1_MAIN,
+    PIX_FMT_VDPAU_VC1_ADVANCED,
     PIX_FMT_NB,        ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
Index: XBMC/xbmc/cores/ffmpeg/avcodec.h
===================================================================
--- XBMC/xbmc/cores/ffmpeg/avcodec.h	(revision 17697)
+++ XBMC/xbmc/cores/ffmpeg/avcodec.h	(working copy)
@@ -190,6 +190,10 @@
     CODEC_ID_MOTIONPIXELS,
     CODEC_ID_TGV,
     CODEC_ID_TGQ,
+    CODEC_ID_MPEGVIDEO_VDPAU,
+    CODEC_ID_H264_VDPAU,
+    CODEC_ID_VC1_VDPAU,
+    CODEC_ID_WMV3_VDPAU,
 
     /* various PCM "codecs" */
     CODEC_ID_PCM_S16LE= 0x10000,
@@ -526,6 +530,10 @@
  * This can be used to prevent truncation of the last audio samples.
  */
 #define CODEC_CAP_SMALL_LAST_FRAME 0x0040
+/**
+ * Codec can export data for HW decoding (VDPAU). 
+ */
+#define CODEC_CAP_HWACCEL_VDPAU    0x0080
 
 //The following defines may change, don't expect compatibility if you use them.
 #define MB_TYPE_INTRA4x4   0x0001
@@ -2298,6 +2306,13 @@
      * - decoding: unused.
      */
     float rc_min_vbv_overflow_use;
+	
+    /**
+     * VDPAU Acceleration
+     * - encoding: forbidden
+     * - decoding: set by decoder
+     */
+    int vdpau_acceleration;
 } AVCodecContext;
 
 /**
Index: XBMC/xbmc/cores/ffmpeg/vdpau_render.h
===================================================================
--- XBMC/xbmc/cores/ffmpeg/vdpau_render.h	(revision 0)
+++ XBMC/xbmc/cores/ffmpeg/vdpau_render.h	(revision 0)
@@ -0,0 +1,445 @@
+/*
+ * The Video Decode and Presentation API for UNIX (VDPAU) is used for
+ * hardware-accelerated decoding of MPEG-1/2, H.264 and VC-1.
+ *
+ * Copyright (C) 2008 NVIDIA
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VDPAU_H
+#define AVCODEC_VDPAU_H
+
+/**
+ * \defgroup Decoder VDPAU Decoder and Renderer
+ *
+ * VDPAU hardware acceleration has two modules
+ * - VDPAU decoding
+ * - VDPAU presentation
+ *
+ * The VDPAU decoding module parses all headers using FFmpeg
+ * parsing mechanisms and uses VDPAU for the actual decoding.
+ *
+ * As per the current implementation, the actual decoding
+ * and rendering (API calls) are done as part of the VDPAU
+ * presentation (vo_vdpau.c) module.
+ *
+ * @{
+ * \defgroup  VDPAU_Decoding VDPAU Decoding
+ * \ingroup Decoder
+ * @{
+ */
+
+#include <vdpau/vdpau.h>
+#include <vdpau/vdpau_x11.h>
+
+/** \brief The videoSurface is used for rendering. */
+#define MP_VDPAU_STATE_USED_FOR_RENDER 1
+
+/**
+ * \brief The videoSurface is needed for reference/prediction.
+ * The codec manipulates this.
+ */
+#define MP_VDPAU_STATE_USED_FOR_REFERENCE 2
+
+#define MP_VDPAU_RENDER_MAGIC   0x1DC8E14B
+
+/**
+ * \brief This structure is used as a callback between the FFmpeg
+ * decoder (vd_) and presentation (vo_) module.
+ * This is used for defining a video frame containing surface,
+ * picture parameter, bitstream information etc which are passed
+ * between the FFmpeg decoder and its clients.
+ */
+typedef struct {
+  int magic;
+  VdpVideoSurface surface; ///< Used as rendered surface, never changed.
+  
+  int state; ///< Holds FF_VDPAU_STATE_* values.
+  
+  /** picture parameter information for all supported codecs */
+  union _VdpPictureInfo {
+    VdpPictureInfoH264     h264;
+    VdpPictureInfoMPEG1Or2 mpeg;
+    VdpPictureInfoVC1       vc1;
+  } info;
+  
+  /** Describe size/location of the compressed video data. */
+  int bitstreamBuffersAllocated;
+  int bitstreamBuffersUsed;
+  VdpBitstreamBuffer *bitstreamBuffers;
+} vdpau_render_state_t;
+
+/* @}*/
+
+#endif /* AVCODEC_VDPAU_H */
+/*
+ * The Video Decode and Presentation API for UNIX (VDPAU) is used for
+ * hardware-accelerated decoding of MPEG-1/2, H.264 and VC-1.
+ *
+ * Copyright (C) 2008 NVIDIA
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VDPAU_H
+#define AVCODEC_VDPAU_H
+
+/**
+ * \defgroup Decoder VDPAU Decoder and Renderer
+ *
+ * VDPAU hardware acceleration has two modules
+ * - VDPAU decoding
+ * - VDPAU presentation
+ *
+ * The VDPAU decoding module parses all headers using FFmpeg
+ * parsing mechanisms and uses VDPAU for the actual decoding.
+ *
+ * As per the current implementation, the actual decoding
+ * and rendering (API calls) are done as part of the VDPAU
+ * presentation (vo_vdpau.c) module.
+ *
+ * @{
+ * \defgroup  VDPAU_Decoding VDPAU Decoding
+ * \ingroup Decoder
+ * @{
+ */
+
+#include <vdpau/vdpau.h>
+#include <vdpau/vdpau_x11.h>
+
+/** \brief The videoSurface is used for rendering. */
+#define MP_VDPAU_STATE_USED_FOR_RENDER 1
+
+/**
+ * \brief The videoSurface is needed for reference/prediction.
+ * The codec manipulates this.
+ */
+#define MP_VDPAU_STATE_USED_FOR_REFERENCE 2
+
+#define MP_VDPAU_RENDER_MAGIC   0x1DC8E14B
+
+/**
+ * \brief This structure is used as a callback between the FFmpeg
+ * decoder (vd_) and presentation (vo_) module.
+ * This is used for defining a video frame containing surface,
+ * picture parameter, bitstream information etc which are passed
+ * between the FFmpeg decoder and its clients.
+ */
+typedef struct {
+  int magic;
+  VdpVideoSurface surface; ///< Used as rendered surface, never changed.
+  
+  int state; ///< Holds FF_VDPAU_STATE_* values.
+  
+  /** picture parameter information for all supported codecs */
+  union _VdpPictureInfo {
+    VdpPictureInfoH264     h264;
+    VdpPictureInfoMPEG1Or2 mpeg;
+    VdpPictureInfoVC1       vc1;
+  } info;
+  
+  /** Describe size/location of the compressed video data. */
+  int bitstreamBuffersAllocated;
+  int bitstreamBuffersUsed;
+  VdpBitstreamBuffer *bitstreamBuffers;
+} vdpau_render_state_t;
+
+/* @}*/
+
+#endif /* AVCODEC_VDPAU_H */
+/*
+ * The Video Decode and Presentation API for UNIX (VDPAU) is used for
+ * hardware-accelerated decoding of MPEG-1/2, H.264 and VC-1.
+ *
+ * Copyright (C) 2008 NVIDIA
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VDPAU_H
+#define AVCODEC_VDPAU_H
+
+/**
+ * \defgroup Decoder VDPAU Decoder and Renderer
+ *
+ * VDPAU hardware acceleration has two modules
+ * - VDPAU decoding
+ * - VDPAU presentation
+ *
+ * The VDPAU decoding module parses all headers using FFmpeg
+ * parsing mechanisms and uses VDPAU for the actual decoding.
+ *
+ * As per the current implementation, the actual decoding
+ * and rendering (API calls) are done as part of the VDPAU
+ * presentation (vo_vdpau.c) module.
+ *
+ * @{
+ * \defgroup  VDPAU_Decoding VDPAU Decoding
+ * \ingroup Decoder
+ * @{
+ */
+
+#include <vdpau/vdpau.h>
+#include <vdpau/vdpau_x11.h>
+
+/** \brief The videoSurface is used for rendering. */
+#define MP_VDPAU_STATE_USED_FOR_RENDER 1
+
+/**
+ * \brief The videoSurface is needed for reference/prediction.
+ * The codec manipulates this.
+ */
+#define MP_VDPAU_STATE_USED_FOR_REFERENCE 2
+
+#define MP_VDPAU_RENDER_MAGIC   0x1DC8E14B
+
+/**
+ * \brief This structure is used as a callback between the FFmpeg
+ * decoder (vd_) and presentation (vo_) module.
+ * This is used for defining a video frame containing surface,
+ * picture parameter, bitstream information etc which are passed
+ * between the FFmpeg decoder and its clients.
+ */
+typedef struct {
+  int magic;
+  VdpVideoSurface surface; ///< Used as rendered surface, never changed.
+  
+  int state; ///< Holds FF_VDPAU_STATE_* values.
+  
+  /** picture parameter information for all supported codecs */
+  union _VdpPictureInfo {
+    VdpPictureInfoH264     h264;
+    VdpPictureInfoMPEG1Or2 mpeg;
+    VdpPictureInfoVC1       vc1;
+  } info;
+  
+  /** Describe size/location of the compressed video data. */
+  int bitstreamBuffersAllocated;
+  int bitstreamBuffersUsed;
+  VdpBitstreamBuffer *bitstreamBuffers;
+} vdpau_render_state_t;
+
+/* @}*/
+
+#endif /* AVCODEC_VDPAU_H */
+/*
+ * The Video Decode and Presentation API for UNIX (VDPAU) is used for
+ * hardware-accelerated decoding of MPEG-1/2, H.264 and VC-1.
+ *
+ * Copyright (C) 2008 NVIDIA
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VDPAU_H
+#define AVCODEC_VDPAU_H
+
+/**
+ * \defgroup Decoder VDPAU Decoder and Renderer
+ *
+ * VDPAU hardware acceleration has two modules
+ * - VDPAU decoding
+ * - VDPAU presentation
+ *
+ * The VDPAU decoding module parses all headers using FFmpeg
+ * parsing mechanisms and uses VDPAU for the actual decoding.
+ *
+ * As per the current implementation, the actual decoding
+ * and rendering (API calls) are done as part of the VDPAU
+ * presentation (vo_vdpau.c) module.
+ *
+ * @{
+ * \defgroup  VDPAU_Decoding VDPAU Decoding
+ * \ingroup Decoder
+ * @{
+ */
+
+#include <vdpau/vdpau.h>
+#include <vdpau/vdpau_x11.h>
+
+/** \brief The videoSurface is used for rendering. */
+#define MP_VDPAU_STATE_USED_FOR_RENDER 1
+
+/**
+ * \brief The videoSurface is needed for reference/prediction.
+ * The codec manipulates this.
+ */
+#define MP_VDPAU_STATE_USED_FOR_REFERENCE 2
+
+#define MP_VDPAU_RENDER_MAGIC   0x1DC8E14B
+
+/**
+ * \brief This structure is used as a callback between the FFmpeg
+ * decoder (vd_) and presentation (vo_) module.
+ * This is used for defining a video frame containing surface,
+ * picture parameter, bitstream information etc which are passed
+ * between the FFmpeg decoder and its clients.
+ */
+typedef struct {
+  int magic;
+  VdpVideoSurface surface; ///< Used as rendered surface, never changed.
+  
+  int state; ///< Holds FF_VDPAU_STATE_* values.
+  
+  /** picture parameter information for all supported codecs */
+  union _VdpPictureInfo {
+    VdpPictureInfoH264     h264;
+    VdpPictureInfoMPEG1Or2 mpeg;
+    VdpPictureInfoVC1       vc1;
+  } info;
+  
+  /** Describe size/location of the compressed video data. */
+  int bitstreamBuffersAllocated;
+  int bitstreamBuffersUsed;
+  VdpBitstreamBuffer *bitstreamBuffers;
+} vdpau_render_state_t;
+
+/* @}*/
+
+#endif /* AVCODEC_VDPAU_H */
+/*
+ * The Video Decode and Presentation API for UNIX (VDPAU) is used for
+ * hardware-accelerated decoding of MPEG-1/2, H.264 and VC-1.
+ *
+ * Copyright (C) 2008 NVIDIA
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_VDPAU_H
+#define AVCODEC_VDPAU_H
+
+/**
+ * \defgroup Decoder VDPAU Decoder and Renderer
+ *
+ * VDPAU hardware acceleration has two modules
+ * - VDPAU decoding
+ * - VDPAU presentation
+ *
+ * The VDPAU decoding module parses all headers using FFmpeg
+ * parsing mechanisms and uses VDPAU for the actual decoding.
+ *
+ * As per the current implementation, the actual decoding
+ * and rendering (API calls) are done as part of the VDPAU
+ * presentation (vo_vdpau.c) module.
+ *
+ * @{
+ * \defgroup  VDPAU_Decoding VDPAU Decoding
+ * \ingroup Decoder
+ * @{
+ */
+
+#include <vdpau/vdpau.h>
+#include <vdpau/vdpau_x11.h>
+
+/** \brief The videoSurface is used for rendering. */
+#define MP_VDPAU_STATE_USED_FOR_RENDER 1
+
+/**
+ * \brief The videoSurface is needed for reference/prediction.
+ * The codec manipulates this.
+ */
+#define MP_VDPAU_STATE_USED_FOR_REFERENCE 2
+
+#define MP_VDPAU_RENDER_MAGIC   0x1DC8E14B
+
+/**
+ * \brief This structure is used as a callback between the FFmpeg
+ * decoder (vd_) and presentation (vo_) module.
+ * This is used for defining a video frame containing surface,
+ * picture parameter, bitstream information etc which are passed
+ * between the FFmpeg decoder and its clients.
+ */
+typedef struct {
+  int magic;
+  VdpVideoSurface surface; ///< Used as rendered surface, never changed.
+  
+  int state; ///< Holds FF_VDPAU_STATE_* values.
+  
+  /** picture parameter information for all supported codecs */
+  union _VdpPictureInfo {
+    VdpPictureInfoH264     h264;
+    VdpPictureInfoMPEG1Or2 mpeg;
+    VdpPictureInfoVC1       vc1;
+  } info;
+  
+  /** Describe size/location of the compressed video data. */
+  int bitstreamBuffersAllocated;
+  int bitstreamBuffersUsed;
+  VdpBitstreamBuffer *bitstreamBuffers;
+} vdpau_render_state_t;
+
+/* @}*/
+
+#endif /* AVCODEC_VDPAU_H */
Index: XBMC/xbmc/GUIWindowSettingsCategory.cpp
===================================================================
--- XBMC/xbmc/GUIWindowSettingsCategory.cpp	(revision 17697)
+++ XBMC/xbmc/GUIWindowSettingsCategory.cpp	(working copy)
@@ -806,6 +806,7 @@
       pControl->AddLabel(g_localizeStrings.Get(13417), RENDER_METHOD_ARB);
       pControl->AddLabel(g_localizeStrings.Get(13418), RENDER_METHOD_GLSL);
       pControl->AddLabel(g_localizeStrings.Get(13419), RENDER_METHOD_SOFTWARE);
+      pControl->AddLabel(g_localizeStrings.Get(13420), RENDER_METHOD_VDPAU);
 #endif
       pControl->SetValue(pSettingInt->GetData());
     }
Index: XBMC/xbmc/lib/libass/test/Makefile.in
===================================================================
--- XBMC/xbmc/lib/libass/test/Makefile.in	(revision 17697)
+++ XBMC/xbmc/lib/libass/test/Makefile.in	(working copy)
@@ -197,9 +197,9 @@
 	      exit 1;; \
 	  esac; \
 	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  test/Makefile'; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  test/Makefile'; \
 	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu  test/Makefile
+	  $(AUTOMAKE) --foreign  test/Makefile
 .PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
Index: XBMC/xbmc/lib/libass/libass/Makefile.in
===================================================================
--- XBMC/xbmc/lib/libass/libass/Makefile.in	(revision 17697)
+++ XBMC/xbmc/lib/libass/libass/Makefile.in	(working copy)
@@ -218,9 +218,9 @@
 	      exit 1;; \
 	  esac; \
 	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  libass/Makefile'; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  libass/Makefile'; \
 	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu  libass/Makefile
+	  $(AUTOMAKE) --foreign  libass/Makefile
 .PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
Index: XBMC/guilib/Surface.h
===================================================================
--- XBMC/guilib/Surface.h	(revision 17697)
+++ XBMC/guilib/Surface.h	(working copy)
@@ -38,6 +38,9 @@
 #include <GL/glew.h>
 #endif
 
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
 namespace Surface {
 #if defined(_WIN32PC)
 /*!
@@ -88,6 +91,8 @@
   void EnableVSync(bool enable=true);
   bool ResizeSurface(int newWidth, int newHeight, bool useNewContext=true);
   void RefreshCurrentContext();
+  bool BindPixmap();
+  bool ReleasePixmap();
   DWORD GetNextSwap();
   void NotifyAppFocusChange(bool bGaining);
 #ifdef _WIN32 
@@ -99,9 +104,12 @@
   GLXContext GetContext() {return m_glContext;}
   GLXWindow GetWindow() {return m_glWindow;}
   GLXPbuffer GetPBuffer() {return m_glPBuffer;}
-  GLXPixmap GetPixmap() {return m_glPixmap;}
+  Pixmap GetXPixmap() {return m_Pixmap;}
+  GLXPixmap GetGLPixmap() {return m_glPixmap;}
   bool MakePBuffer();
-  bool MakePixmap();
+  bool MakePixmap(int width, int height);
+  Display* GetDisplay() {return s_dpy;}
+  GLuint GetGLPixmapTex() {return m_glPixmapTexture;}
 #endif
 
   static std::string& GetGLVendor() { return s_glVendor; }
@@ -112,6 +120,7 @@
   SDL_Surface* SDL() {return m_SDLSurface;}
 
  protected:
+  bool m_pixmapBound;
   CSurface* m_pShared;
   int m_iWidth;
   int m_iHeight;
@@ -133,7 +142,9 @@
   GLXWindow  m_glWindow;
   Window  m_parentWindow;
   GLXPixmap  m_glPixmap;
+  Pixmap  m_Pixmap;
   GLXPbuffer  m_glPBuffer;
+  GLuint   m_glPixmapTexture;
   static Display* s_dpy;
 #endif
 #ifdef __APPLE__
Index: XBMC/guilib/Surface.cpp
===================================================================
--- XBMC/guilib/Surface.cpp	(revision 17697)
+++ XBMC/guilib/Surface.cpp	(working copy)
@@ -39,7 +39,16 @@
 #endif
 
 #ifdef HAS_GLX
+
+#define CHECK_GL \
+  rv = glGetError(); \
+  if (rv) \
+    CLog::Log(LOGERROR, "openGL Error: %i",rv);
+
+
 Display* CSurface::s_dpy = 0;
+PFNGLXBINDTEXIMAGEEXTPROC glXBindTexImageEXT = NULL;
+PFNGLXRELEASETEXIMAGEEXTPROC glXReleaseTexImageEXT = NULL;
 
 static Bool WaitForNotify(Display *dpy, XEvent *event, XPointer arg)
 {
@@ -81,6 +90,7 @@
 {
   CLog::Log(LOGDEBUG, "Constructing surface %dx%d, shared=%p, fullscreen=%d\n", width, height, (void *)shared, fullscreen);
   m_bOK = false;
+  m_pixmapBound = false;
   m_iWidth = width;
   m_iHeight = height;
   m_bDoublebuffer = doublebuffer;
@@ -96,6 +106,13 @@
   m_iSwapTime = 0;
   m_iSwapRate = 0;
   m_bVsyncInit = false;
+  m_glPixmapTexture = 0;
+  if (!glXBindTexImageEXT)
+    glXBindTexImageEXT = (PFNGLXBINDTEXIMAGEEXTPROC) 
+      glXGetProcAddress((GLubyte *) "glXBindTexImageEXT");
+  if (!glXReleaseTexImageEXT)
+    glXReleaseTexImageEXT = (PFNGLXRELEASETEXIMAGEEXTPROC)
+      glXGetProcAddress((GLubyte *) "glXReleaseTexImageEXT");
 
 #ifdef __APPLE__
   m_glContext = 0;
@@ -116,6 +133,7 @@
   m_glContext = 0;
   m_glPBuffer = 0;
   m_glPixmap = 0;
+  m_Pixmap = 0;
 
   GLXFBConfig *fbConfigs = 0;
   bool mapWindow = false;
@@ -191,7 +209,7 @@
 
   if (pixmap)
   {
-    MakePixmap();
+    MakePixmap(width,height);
     return;
   }
 
@@ -226,6 +244,10 @@
 
   // obtain the xvisual from the first compatible framebuffer
   vInfo = glXGetVisualFromFBConfig(s_dpy, fbConfigs[0]);
+  if (!vInfo) {
+	CLog::Log(LOGERROR, "GLX Error: vInfo is NULL!");
+	return;
+  }
 
   // if no window is specified, create a window because a GL context needs to be
   // associated to a window
@@ -515,11 +537,203 @@
   return status;
 }
 
-bool CSurface::MakePixmap()
+bool CSurface::BindPixmap()
 {
-// FIXME: this needs to be implemented
+  int rv=0;
+  GLXContext mainContext = glXGetCurrentContext();
+  Display* xDisplay = glXGetCurrentDisplay();
+  GLXDrawable mainDrawable = glXGetCurrentDrawable();
+  if (mainContext && xDisplay && mainDrawable && !m_pixmapBound) {
+    glXMakeContextCurrent(xDisplay, m_glPixmap, m_glPixmap, mainContext);
+    glBindTexture (GL_TEXTURE_2D, m_glPixmapTexture);
+    glXBindTexImageEXT(xDisplay, m_glPixmap, GLX_FRONT_LEFT_EXT, NULL);
+    CHECK_GL
+    glXMakeContextCurrent(xDisplay, mainDrawable, m_glPixmap, mainContext);
+    if (!rv) {
+      m_pixmapBound = true;
+      CLog::Log(LOGNOTICE,"BindPixmap() success");
+      return true;
+    }
+    else CLog::Log(LOGERROR,"BindPixmap() error - rv 0x%x",rv);
+  }
+  CLog::Log(LOGERROR,"BindPixmap()failed");
   return false;
 }
+
+bool CSurface::ReleasePixmap()
+{
+  int rv;
+  GLXContext mainContext = glXGetCurrentContext();
+  Display* xDisplay = glXGetCurrentDisplay();
+  GLXDrawable mainDrawable = glXGetCurrentDrawable();
+  glEnable(GL_TEXTURE_2D);
+  glXMakeContextCurrent(xDisplay, mainDrawable, mainDrawable, mainContext);
+  glBindTexture (GL_TEXTURE_2D, m_glPixmapTexture);
+  glXReleaseTexImageEXT(xDisplay, m_glPixmap,
+                        GLX_FRONT_LEFT_EXT);
+  glBindTexture (GL_TEXTURE_2D, 0);
+  glXDestroyGLXPixmap (xDisplay, m_glPixmap);
+  CHECK_GL
+  if (rv) 
+    return false;
+  else
+    return true;
+}
+
+bool CSurface::MakePixmap(int width, int height)
+{
+	int num, rv=0;
+	GLXFBConfig *fbConfigs=NULL;
+	int fbConfigIndex = 0;
+	XVisualInfo *visInfo=NULL;
+	
+	bool status = false;
+	int singleVisAttributes[] =
+ {
+   GLX_RENDER_TYPE, GLX_RGBA_BIT,
+   GLX_RED_SIZE, m_iRedSize,
+   GLX_GREEN_SIZE, m_iGreenSize,
+   GLX_BLUE_SIZE, m_iBlueSize,
+   GLX_ALPHA_SIZE, m_iAlphaSize,
+   GLX_DEPTH_SIZE, 8,
+   GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
+   GLX_BIND_TO_TEXTURE_RGBA_EXT, True,
+   GLX_X_RENDERABLE, True, // Added by Rob
+   None
+ };
+	
+	int doubleVisAttributes[] =
+ {
+   GLX_RENDER_TYPE, GLX_RGBA_BIT,
+   GLX_RED_SIZE, m_iRedSize,
+   GLX_GREEN_SIZE, m_iGreenSize,
+   GLX_BLUE_SIZE, m_iBlueSize,
+   GLX_ALPHA_SIZE, m_iAlphaSize,
+   GLX_DEPTH_SIZE, 8,
+   GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
+   GLX_BIND_TO_TEXTURE_RGBA_EXT, True,
+   GLX_DOUBLEBUFFER, True,
+   GLX_Y_INVERTED_EXT, True,
+   GLX_X_RENDERABLE, True, // Added by Rob
+   None
+ };
+	
+	int pixmapAttribs[] = 
+ {
+   GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,
+   GLX_TEXTURE_FORMAT_EXT, GLX_TEXTURE_FORMAT_RGBA_EXT,
+   None
+ };
+	
+	if (m_bDoublebuffer)
+   {
+     fbConfigs = glXChooseFBConfig(s_dpy, DefaultScreen(s_dpy), doubleVisAttributes, &num);
+   } else {
+     fbConfigs = glXChooseFBConfig(s_dpy, DefaultScreen(s_dpy), singleVisAttributes, &num);
+   }
+	
+	// Get our window attribs.
+	XWindowAttributes wndattribs;
+	XGetWindowAttributes(s_dpy, DefaultRootWindow(s_dpy), &wndattribs); // returns a status but I don't know what success is
+	
+	//VisualID visualid = XVisualIDFromVisual (wndattribs.visual);
+	//if (!visualid) {
+	//	CLog::Log(LOGERROR, "Error: visualid is NULL.");
+	//	XFree(fbConfigs);
+	//	return status;
+	//}
+	
+	CLog::Log(LOGDEBUG, "Found %d fbconfigs.", num);
+	//for (fbConfigIndex = 0; fbConfigIndex < num; fbConfigIndex++)  {
+	//	visInfo = glXGetVisualFromFBConfig (s_dpy, fbConfigs[fbConfigIndex]);
+	//	if (!visInfo || visInfo->visualid != visualid) {
+	//		CLog::Log(LOGDEBUG, "Looking for visualID %d but found %d.", visualid, visInfo->visualid);
+  //    		continue;
+	//	}
+	//	break;
+	//}
+	fbConfigIndex = 1;
+	//if ((fbConfigs==NULL) || (fbConfigIndex == num))
+	if (fbConfigs==NULL) 
+   {
+     CLog::Log(LOGERROR, "GLX Error: MakePixmap: No compatible framebuffers found");
+     XFree(fbConfigs);
+     return status;
+   }
+	CLog::Log(LOGDEBUG, "Using fbconfig index %d.", fbConfigIndex);
+	m_Pixmap = XCreatePixmap(s_dpy,
+                           DefaultRootWindow(s_dpy),
+                           width,
+                           height,
+                           wndattribs.depth);
+	
+	//m_Pixmap = XCompositeNameWindowPixmap(s_dpy, DefaultRootWindow(s_dpy));
+	if (!m_Pixmap)
+   {
+     CLog::Log(LOGERROR, "GLX Error: MakePixmap: Unable to create XPixmap");
+     XFree(fbConfigs);
+     return status;
+   }
+	m_glPixmap = glXCreatePixmap(s_dpy, fbConfigs[fbConfigIndex], m_Pixmap, pixmapAttribs);
+	
+	if (m_glPixmap)
+   {
+     CLog::Log(LOGINFO, "GLX: Created Pixmap context");
+     visInfo = glXGetVisualFromFBConfig(s_dpy, fbConfigs[fbConfigIndex]);
+     if (!visInfo)
+      {
+        CLog::Log(LOGINFO, "GLX Error: Could not obtain X Visual Info for pixmap");
+        return false;
+      }
+     if (m_pShared)
+      {
+        CLog::Log(LOGINFO, "GLX: Creating shared Pixmap context");
+        m_glContext = glXCreateContext(s_dpy, visInfo, m_pShared->GetContext(), True);
+      } else {
+        CLog::Log(LOGINFO, "GLX: Creating unshared Pixmap context");
+        m_glContext = glXCreateContext(s_dpy, visInfo, NULL, True);
+      }
+     XFree(visInfo);
+     if (glXMakeCurrent(s_dpy, m_glPixmap, m_glContext))
+      {
+        CLog::Log(LOGINFO, "GL: Initialised Pixmap");
+        if (!b_glewInit)
+         {
+           if (glewInit()!=GLEW_OK)
+            {
+              CLog::Log(LOGERROR, "GL: Critical Error. Could not initialise GL Extension Wrangler Library");
+            } else {
+              b_glewInit = true;
+              if (s_glVendor.length()==0)
+               {
+                 s_glVendor = (const char*)glGetString(GL_VENDOR);
+                 CLog::Log(LOGINFO, "GL: OpenGL Vendor String: %s", s_glVendor.c_str());
+               }
+            }
+         }
+        
+        GLenum glErr;
+        if (!m_glPixmapTexture) {
+          glGenTextures (1, &m_glPixmapTexture);
+          glErr = glGetError();
+          if ((glErr == GL_INVALID_VALUE) | (glErr == GL_INVALID_OPERATION)) {
+            CLog::Log(LOGINFO, "glGenTextures returned an error!");
+            status = false;
+          }
+        }
+      } else {
+        CLog::Log(LOGINFO, "GLX Error: Could not make Pixmap current");
+        status = false;
+      }
+   }
+	else
+   {
+     CLog::Log(LOGINFO, "GLX Error: Could not create Pixmap");
+     status = false;
+   }
+	XFree(fbConfigs);
+	return status;
+}
 #endif
 
 CSurface::~CSurface()
@@ -535,6 +749,18 @@
     CLog::Log(LOGINFO, "GLX: Destroying PBuffer");
     glXDestroyPbuffer(s_dpy, m_glPBuffer);
   }
+  if (m_glPixmap)
+  {
+    CLog::Log(LOGINFO, "GLX: Destroying glPixmap");
+    ReleasePixmap();
+    m_glPixmap = NULL;
+  }
+  if (m_Pixmap)
+  {
+    CLog::Log(LOGINFO, "GLX: Destroying XPixmap");
+    XFreePixmap(s_dpy, m_Pixmap);
+    m_Pixmap = NULL;
+  }
   if (m_glWindow && !IsShared())
   {
     CLog::Log(LOGINFO, "GLX: Destroying Window");
@@ -855,6 +1081,10 @@
   {
     return (bool)glXMakeCurrent(s_dpy, m_glPBuffer, m_glContext);
   }
+  else if (m_glPixmap)
+  {
+    return (bool)glXMakeCurrent(s_dpy, m_glPixmap, m_glContext);
+  }
 #endif
 
 #ifdef __APPLE__
