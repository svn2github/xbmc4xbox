diff -NaurwB streamdev/Makefile streamdev2/Makefile
--- streamdev/Makefile	2009-07-01 12:46:15.000000000 +0200
+++ streamdev2/Makefile	2009-07-07 08:47:12.000000000 +0200
@@ -62,6 +62,7 @@
 	server/connectionVTP.o server/connectionHTTP.o server/connectionIGMP.o \
 	server/streamer.o server/livestreamer.o server/livefilter.o \
 	server/suspend.o server/setup.o server/menuHTTP.o server/recplayer.o \
+	server/txtrecv.o \
 	remux/tsremux.o remux/ts2pes.o remux/ts2ps.o remux/ts2es.o remux/extern.o
 	
 ifdef DEBUG
diff -NaurwB streamdev/server/connectionVTP.c streamdev2/server/connectionVTP.c
--- streamdev/server/connectionVTP.c	2009-07-02 08:03:51.000000000 +0200
+++ streamdev2/server/connectionVTP.c	2009-07-07 09:06:26.000000000 +0200
@@ -6,6 +6,7 @@
 #include "server/livestreamer.h"
 #include "server/suspend.h"
 #include "setup.h"
+#include "txtrecv.h"
 
 #include <vdr/tools.h>
 #include <vdr/videodir.h>
@@ -845,6 +846,7 @@
 	else if (strcasecmp(Cmd, "DELC") == 0) return CmdDELC(param);
 	else if (strcasecmp(Cmd, "DELR") == 0) return CmdDELR(param);
 	else if (strcasecmp(Cmd, "RENR") == 0) return CmdRENR(param);
+	else if (strcasecmp(Cmd, "LTXT") == 0) return CmdLTXT(param);
 	else
 		return Respond(500, "Unknown Command \"%s\"", Cmd);
 }
@@ -1074,6 +1076,8 @@
 	if(m_LiveSocket)
 		m_LiveStreamer->Start(m_LiveSocket);
 	
+	m_Teletext.SetChannel(chan);
+
 	if(m_FiltersSupport) {
 		if(!m_FilterStreamer)
 			m_FilterStreamer = new cStreamdevFilterStreamer;
@@ -1397,22 +1401,52 @@
 {
 	INIT_WRAPPER();
 	if (*Option) {
-		if (isnumber(Option)) {
-			cTimer *timer = Timers.Get(strtol(Option, NULL, 10) - 1);
+		int number = 0;
+		bool force = false;
+		char buf[strlen(Option) + 1];
+		strcpy(buf, Option);
+		const char *delim = " \t";
+		char *strtok_next;
+		char *p = strtok_r(buf, delim, &strtok_next);
+
+		if (isnumber(p)) {
+			number = strtol(p, NULL, 10) - 1;
+		}
+		else if (strcasecmp(p, "FORCE") == 0) {
+			force = true;
+		}
+		if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
+			if (isnumber(p)) {
+				number = strtol(p, NULL, 10) - 1;
+			}
+			else if (strcasecmp(p, "FORCE") == 0) {
+				force = true;
+			}
+			else {
+				Reply(501, "Timer not found or wrong syntax");
+			}
+		}
+
+		cTimer *timer = Timers.Get(number);
 			if (timer) {
-				if (!timer->Recording()) {
+			if (timer->Recording()) {
+				if (force) {
+					timer->Skip();
+					cRecordControls::Process(time(NULL));
+				}
+				else {
+					Reply(550, "Timer \"%i\" is recording", number);
+					EXIT_WRAPPER();
+				}
+			}
 					isyslog("deleting timer %s", *timer->ToDescr());
 					Timers.Del(timer);
 					Timers.SetModified();
-					Reply(250, "Timer \"%s\" deleted", Option);
-				} else
-					Reply(550, "Timer \"%s\" is recording", Option);
-			} else
-				Reply(501, "Timer \"%s\" not defined", Option);
+			Reply(250, "Timer \"%i\" deleted", number);
 		} else
-			Reply(501, "Error in timer number \"%s\"", Option);
+			Reply(501, "Timer \"%i\" not defined", number);
 	} else
-		Reply(501, "Missing timer number");
+		Reply(501, "Missing timer option");
 	EXIT_WRAPPER();
 }
 
@@ -1704,6 +1738,105 @@
 	EXIT_WRAPPER();
 }
 
+bool cConnectionVTP::CmdLTXT(char *Opts)
+{
+	if (*Opts) {
+		int channel = 0;
+		int page = 0;
+		int subpage = 0;
+		bool check_only;
+
+		char buf[strlen(Opts) + 1];
+		strcpy(buf, Opts);
+		const char *delim = " \t";
+		char *strtok_next;
+		char *p = strtok_r(buf, delim, &strtok_next);
+		
+		if (strcasecmp(p, "PRESENT") == 0) {
+		  check_only = true;
+		}
+		else if (strcasecmp(p, "GET") == 0) {
+		  check_only = false;
+		}
+		else {
+			return Respond(501, "Teletext wrong syntax");
+		}
+
+		if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
+			channel = strtol(p, NULL, 10);
+		}
+		else {
+			return Respond(501, "Teletext wrong syntax");
+		}
+
+		if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
+			if (isnumber(p)) {
+				page = strtol(p, NULL, 10);
+			}
+			else {
+				return Respond(501, "Teletext wrong syntax");
+			}
+		}
+
+		if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
+			if (isnumber(p)) {
+				subpage = strtol(p, NULL, 10);
+			}
+			else {
+				return Respond(501, "Teletext wrong syntax");
+			}
+		}
+
+		// Load the page and decodes it
+		unsigned char cache[40*24+12+1];
+		StorageHandle fd;
+		// Take a look if there is a xxx-00 page
+		Storage *s=Storage::instance();
+
+		if (check_only) {
+			if (!(fd=s->openForReading(PageID(Channels.GetByNumber(channel)->GetChannelID(), page, subpage), false)) )
+				return Respond(501, "Page %3x-%02x not found",page, subpage);
+
+			s->close(fd);
+			return Respond(250, "PAGEPRESENT");
+		}
+		else
+		{
+			if (subpage==0) {
+				if ( !(fd=s->openForReading(PageID(Channels.GetByNumber(channel)->GetChannelID(), page, subpage), false)) ) {
+					// There is no subpage 0 so look if there is subpage 1
+					subpage++;
+					// Generate file string
+				} else {
+					// yes file exists
+					s->close(fd);
+				}
+			}
+
+			if ( (fd=s->openForReading(PageID(Channels.GetByNumber(channel)->GetChannelID(), page, subpage), true)) )
+			{
+				s->read(cache,sizeof cache,fd); // Read full page data
+				s->close(fd);
+
+				char buffer [4096];
+				int written = 0;
+				for (int i = 0; i < 40*24+12; i++)
+				{
+					 written += sprintf (buffer+written, "%d ", cache[i]);
+				}
+				sprintf (buffer+written, "END DATA");
+				return Respond(250, "%s", buffer);
+			}
+			else {
+				return Respond(501, "Page %3x-%02x not found",page, subpage);
+			}
+		}
+	}
+	else {
+		return Respond(500, "Missing teletext option");
+	}
+}
+
 bool cConnectionVTP::Respond(int Code, const char *Message, ...)
 {
 	char *buffer;
diff -NaurwB streamdev/server/connectionVTP.h streamdev2/server/connectionVTP.h
--- streamdev/server/connectionVTP.h	2009-07-01 12:46:16.000000000 +0200
+++ streamdev2/server/connectionVTP.h	2009-07-07 08:01:28.000000000 +0200
@@ -3,6 +3,7 @@
 
 #include "server/connection.h"
 #include "server/recplayer.h"
+#include "server/txtrecv.h"
 
 class cTBSocket;
 class cStreamdevLiveStreamer;
@@ -25,6 +26,7 @@
 	cStreamdevFilterStreamer *m_FilterStreamer;
 	cTBSocket                *m_RecSocket;
 	cTBSocket                *m_DataSocket;
+	cTxtStatus                m_Teletext;
 
 	char                   *m_LastCommand;
 	eStreamType             m_StreamType;
@@ -86,6 +88,8 @@
 	bool CmdDELR(const char *Option);
 	bool CmdRENR(const char *Option);
 
+	bool CmdLTXT(char *Opts);
+
 	bool Respond(int Code, const char *Message, ...)
 			__attribute__ ((format (printf, 3, 4)));
 };
diff -NaurwB streamdev/server/txtrecv.c streamdev2/server/txtrecv.c
--- streamdev/server/txtrecv.c	1970-01-01 01:00:00.000000000 +0100
+++ streamdev2/server/txtrecv.c	2009-07-07 08:43:42.000000000 +0200
@@ -0,0 +1,723 @@
+/***************************************************************************
+ *       Copyright (c) 2003,2004 by Marcel Wiesweg                         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <dirent.h>
+
+#include "txtrecv.h"
+#include "txttables.h"
+#include "setup.h"
+#include "menu.h"
+
+#include <vdr/channels.h>
+#include <vdr/device.h>
+#include <vdr/config.h>
+
+#include <pthread.h> 
+#include <signal.h> 
+#include <errno.h>
+#include <sys/vfs.h> 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+const char *RootDir::root = "/var/cache/vdr/vtx";
+
+void RootDir::setRootDir(const char *newRoot) {
+   root=newRoot;
+}
+
+const char *RootDir::getRootDir() {
+   return root;
+}
+
+int Storage::doCleanUp() {
+   DIR *top=opendir(root);
+   int pagesDeleted=0;
+   if (top) {
+      struct dirent *chandir, path;
+      struct stat chandirstat;
+      char fullPath[PATH_MAX];
+      while ( (!readdir_r(top, &path, &chandir) && chandir != NULL) ) {
+         if (strcmp(chandir->d_name, "..")==0 || strcmp(chandir->d_name, ".")==0)
+            continue;
+         snprintf(fullPath, PATH_MAX, "%s/%s", root, chandir->d_name);
+         if (stat(fullPath, &chandirstat)==0) {
+            if (S_ISDIR(chandirstat.st_mode)) {
+               pagesDeleted+=cleanSubDir(fullPath);
+            }
+         }
+      }
+      closedir(top);
+   } else {
+      esyslog("OSD-Teletext: Error opening teletext storage directory \"%s\": %s", root, strerror(errno));
+   }
+   return pagesDeleted;
+}
+
+int Storage::cleanSubDir(const char *dir) {
+   static bool reportedError=false; //avoid filling up syslog
+   DIR *d=opendir(dir);
+   bool hadError=false;
+   int bytesDeleted=0, filesize;
+   if (d) {
+      struct dirent *txtfile, path;
+      struct stat txtfilestat;
+      char fullPath[PATH_MAX];
+      while ( (!readdir_r(d, &path, &txtfile) && txtfile != NULL) ) {
+         int len=strlen(txtfile->d_name);
+         //check that the file end with .vtx to avoid accidents and disasters
+         if (strcmp(txtfile->d_name+len-4, ".vtx")==0) {
+            snprintf(fullPath, PATH_MAX, "%s/%s", dir, txtfile->d_name);
+            stat(fullPath, &txtfilestat);
+            filesize=actualFileSize(txtfilestat.st_size);
+            int ret=unlink(fullPath);
+            if (ret==0)
+               bytesDeleted+=filesize;
+            else
+               hadError=ret;
+         }
+      }
+      closedir(d);
+      rmdir(dir);
+   } else {
+      if (!reportedError) {
+         esyslog("OSD-Teletext: Error opening teletext storage subdirectory \"%s\": %s", dir, strerror(errno));
+         reportedError=true;
+      }
+   }
+
+   if (hadError && !reportedError) {
+      esyslog("OSD-Teletext: Error removing teletext storage subdirectory \"%s\": %s", dir, strerror(hadError));
+      reportedError=true;
+   }
+   return bytesDeleted;
+}
+
+Storage *Storage::s_self = 0;
+Storage::StorageSystem Storage::system = Storage::StorageSystemPacked;
+
+Storage::Storage() {
+   s_self=this;
+   byteCount=0;
+   storageOption=-1;
+   failedFreeSpace=false;
+}
+
+Storage::~Storage() {
+}
+
+void Storage::setSystem(StorageSystem s) {
+   system=s;
+}
+
+Storage *Storage::instance() {
+   if (!s_self) {
+      switch (system) {
+      case StorageSystemLegacy:
+         s_self=new LegacyStorage();
+         break;
+      case StorageSystemPacked:
+      default:
+         s_self=new PackedStorage();
+         break;
+      }
+   }
+   return s_self;
+}
+
+void Storage::setMaxStorage(int maxMB) {
+   storageOption=maxMB;
+}
+
+void Storage::init() {
+   cleanUp();
+   initMaxStorage(storageOption);
+}
+
+void Storage::freeSpace() {
+   //there might be a situation where only the current directory is left and
+   //occupies the whole space. We cannot delete anything. Don't waste time scanning.
+   if (failedFreeSpace)
+      return;
+
+   //printf("freeSpace()\n");
+   time_t min=time(0);
+   char minDir[PATH_MAX];
+   char fullPath[PATH_MAX];
+   int haveDir=0;
+   DIR *top=opendir(getRootDir());
+   if (top) {
+      struct dirent *chandir, path;
+      struct stat chandirstat;
+      while ( (!readdir_r(top, &path, &chandir) && chandir != NULL) ) {
+         if (strcmp(chandir->d_name, "..")==0 || strcmp(chandir->d_name, ".")==0)
+            continue;
+         snprintf(fullPath, PATH_MAX, "%s/%s", getRootDir(), chandir->d_name);
+         if (stat(fullPath, &chandirstat)==0) {
+            if (S_ISDIR(chandirstat.st_mode)) {
+               if (chandirstat.st_ctime < min && strcmp(fullPath, currentDir)) {
+                  min=chandirstat.st_ctime;
+                  strcpy(minDir, fullPath);
+                  haveDir++;
+               }
+            }
+         }
+      }
+      closedir(top);
+
+      //if haveDir, only current directory present, which must not be deleted
+      if (haveDir>=2)
+         byteCount-=cleanSubDir(minDir);
+      else
+         failedFreeSpace=true;
+   }
+}
+
+bool Storage::exists(const char* file) {
+   struct stat s;
+   return (stat(file, &s)==0);
+}
+
+void Storage::getFilename(char *buffer, int bufLength, PageID page) {
+   snprintf(buffer, bufLength, "%s/%s/%03x_%02x.vtx", getRootDir(),
+            *page.channel.ToString(), page.page, page.subPage);
+}
+
+void Storage::prepareDirectory(tChannelID chan) {
+   currentDir = cString::sprintf("%s/%s", root, *chan.ToString());
+   if (!MakeDirs(currentDir, 1)) {
+      esyslog("OSD-Teletext: Error preparing directory for channel \"%s\"",
+              *chan.ToString());
+      return;
+   }
+   failedFreeSpace=false;
+}
+
+#define TELETEXT_PAGESIZE 972
+
+LegacyStorage::LegacyStorage() {
+   maxBytes=0;
+   fsBlockSize=1;
+   pageBytes=TELETEXT_PAGESIZE;
+}
+
+LegacyStorage::~LegacyStorage() {
+}
+
+/*
+static inline int FilesForMegabytes(double MB, int blocksize) {
+   double pageBytes;
+   if (TELETEXT_PAGESIZE<=blocksize)
+      pageBytes=blocksize;
+   else
+      pageBytes=((TELETEXT_PAGESIZE/blocksize)+1)*blocksize;
+   //reserve 10% for directories
+   return (int)( (1024.0 * 1024.0 * (MB-MB*0.1)) / pageBytes );
+}*/
+
+int LegacyStorage::actualFileSize(int netFileSize) {
+   if (netFileSize<=0)
+      return 0;
+   if (netFileSize<=fsBlockSize)
+      return fsBlockSize;
+   else
+      return ((netFileSize/fsBlockSize)+1)*fsBlockSize;
+}
+
+//max==0 means unlimited, max==-1 means a reasonable default value shall be calculated
+void LegacyStorage::initMaxStorage(int maxMB) {
+   struct statfs fs;
+   if (statfs(getRootDir(), &fs)!=0) {
+      esyslog("OSD-Teletext: Error statfs'ing root directory \"%s\": %s, cache size uncontrolled", getRootDir(), strerror(errno));
+      return;
+   }
+   fsBlockSize=fs.f_bsize;
+
+   pageBytes=actualFileSize(TELETEXT_PAGESIZE);
+
+   if (maxMB>=0) {
+      if (maxMB<3) {
+         esyslog("OSD-Teletext: Request to use at most %d MB for caching. This is not enough, using 3 MB", maxMB);
+         maxMB=3;
+      }
+      maxBytes=MEGABYTE(maxMB);
+   } else if (maxMB==-1) {
+      //calculate a default value
+      double blocksPerMeg = 1024.0 * 1024.0 / fs.f_bsize;
+      double capacityMB=fs.f_blocks / blocksPerMeg;
+      double freeMB=(fs.f_bavail / blocksPerMeg);
+      if (capacityMB<=50 || freeMB<50) {
+         //small (<=50MB) filesystems as root dir are assumed to be dedicated for use as a teletext cache
+         //for others, the maximum default size is set to 50 MB
+         maxBytes=MEGABYTE((int)freeMB);
+         //maxPages= FilesForMegabytes(freeMB, fs.f_bsize);
+         if (freeMB<3.0) {
+            esyslog("OSD-Teletext: Less than %.1f MB free on filesystem of root directory \"%s\"!", freeMB, getRootDir());
+            maxBytes=MEGABYTE(3);
+         }
+      } else {
+         //the maximum default size is set to 50 MB
+         maxBytes=MEGABYTE(50);
+      }
+      //printf("Set maxBytes to %ld, %.2f %.2f\n", maxBytes, capacityMB, freeMB);
+   }
+}
+
+void LegacyStorage::cleanUp() {
+   byteCount -= Storage::doCleanUp();
+}
+
+void LegacyStorage::registerFile(PageID page) {
+   //pageBytes is already effective size
+   if ( maxBytes && (byteCount+=pageBytes)>maxBytes )
+      freeSpace();
+}
+
+StorageHandle LegacyStorage::openForReading(PageID page, bool countAsAccess) {
+   //the countAsAccess argument was intended for use in a LRU cache, currently unused
+   char filename[PATH_MAX];
+   getFilename(filename, sizeof(filename), page);
+   StorageHandle ret=(StorageHandle)open(filename, O_RDONLY);
+   return ret;
+}
+
+StorageHandle LegacyStorage::openForWriting(PageID page) {
+   static bool wroteError=false;
+   char filename[PATH_MAX];
+   getFilename(filename, sizeof(filename), page);
+   bool existed=exists(filename);
+   //first try
+   StorageHandle fd=(StorageHandle)open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+   if (fd) {
+      if (!existed)
+         registerFile(page);
+      return fd;
+   }
+   //no space on disk? make some space available
+   if (errno == ENOSPC)
+      freeSpace();
+   //second try
+   fd=(StorageHandle)open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+   if (!fd && !wroteError) {
+      //report error to syslog - once!
+      wroteError=true;
+      esyslog("OSD-Teletext: Error opening teletext file %s: %s", filename, strerror(errno));
+   }
+   //make sure newly created files are counted
+   if (fd && !existed)
+      registerFile(page);
+   return fd;
+}
+
+ssize_t LegacyStorage::write(const void *ptr, size_t size, StorageHandle stream) {
+   ssize_t written;
+   if (!(written=::write((int)stream, ptr, size)) ) {
+      switch (errno) {
+      case ENOSPC:
+         freeSpace();
+         return ::write((int)stream, ptr, size);
+      case EINTR:
+         esyslog("OSD-Teletext: EINTR while writing. Please contact the author and tell him this happened.");
+         break;
+      default:
+         break;
+      }
+   }
+   return written;
+}
+
+
+
+PackedStorage::PackedStorage() {
+}
+#define TOC_SIZE 8
+//The file structure is simple:
+// TOC_SIZE*PageAddress contains the numbers of the following pages
+// TOC_SIZE*TELETEXT_PAGESIZE contains the page data
+//and the same again.
+bool PackedStorage::seekTo(PageID page, int desc, bool create) {
+   lseek(desc, 0, SEEK_SET);
+   PageAddress addr[TOC_SIZE];
+
+   while (::read(desc, addr, sizeof(addr)) == sizeof(addr)) {
+      lseek(desc, 0, SEEK_CUR);
+      for (int index=0; index<TOC_SIZE; index++) {
+         if (addr[index]==page) {
+            lseek(desc, index*TELETEXT_PAGESIZE, SEEK_CUR);
+            return true;
+         } else if (addr[index].page==0) {
+            //0 means: no more pages follow
+            if (create) {
+               //rewind what was read
+               lseek(desc, -(off_t)sizeof(addr), SEEK_CUR);
+               //update index
+               addr[index]=page;
+               if (::write(desc, addr, sizeof(addr)) != sizeof(addr))
+                  return false;
+               //seek to data position
+               lseek(desc, TELETEXT_PAGESIZE*index, SEEK_CUR);
+               return true;
+            } else
+               return false;
+         }
+      }
+
+      //seek over data area
+      lseek(desc, TELETEXT_PAGESIZE*TOC_SIZE, SEEK_CUR);
+   }
+
+   int oldSize=actualFileSize(lseek(desc, 0, SEEK_CUR));
+   if (create) {
+      //create a new set of a TOC and a TOC_SIZE*TELETEXT_PAGESIZE data area
+      memset(addr, 0, sizeof(addr));
+      //first entry is our page
+      addr[0]=page;
+      if (::write(desc, addr, sizeof(addr)) != sizeof(addr))
+         return false;
+      //seek beyond end of file
+      lseek(desc, (TELETEXT_PAGESIZE*TOC_SIZE)-1, SEEK_CUR);
+      //write one byte to enlarge the file to the sought position
+      char c=1;
+      if (::write(desc, &c, 1) != 1)
+         return false;
+      //Now, calculate new file size
+      byteCount += ( actualFileSize(lseek(desc, 0, SEEK_CUR)) - oldSize );
+      //seek to beginning of data, which is requested
+      lseek(desc, -(off_t)(TELETEXT_PAGESIZE*TOC_SIZE), SEEK_CUR);
+      return true;
+   } else
+      return false;
+}
+
+void PackedStorage::getFilename(char *buffer, int bufLength, PageID page) {
+   //This is a different scheme: page 576_07 will have the name 570s.vtx, the same as e.g. 571_01 or 575_00
+   //Think of "the five hundred seventies"
+   snprintf(buffer, bufLength, "%s/%s/%03xs.vtx", getRootDir(),
+            *page.channel.ToString(), (page.page & 0xFF0));
+}
+
+StorageHandle PackedStorage::openForWriting(PageID page) {
+   static bool wroteError=false;
+   char filename[PATH_MAX];
+   getFilename(filename, sizeof(filename), page);
+   //first try
+   int desc=open(filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+   if (desc != -1) {
+      if (!seekTo(page, desc, true)) {
+         ::close(desc);
+         return StorageHandle();
+      }
+      if ( maxBytes && byteCount>maxBytes )
+         freeSpace();
+      return (StorageHandle)desc;
+   }
+   //no space on disk? make some space available
+   if (errno == ENOSPC)
+      freeSpace();
+   //second try
+   desc=open(filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+   if (desc==-1 && !wroteError) {
+      //report error to syslog - once!
+      wroteError=true;
+      esyslog("OSD-Teletext: Error opening teletext file %s: %s", filename, strerror(errno));
+   }
+
+   if (desc==-1)
+      return StorageHandle();
+   else if (!seekTo(page, desc, true)) {
+      ::close(desc);
+      return StorageHandle();
+   }
+
+   if ( maxBytes && byteCount>maxBytes )
+      freeSpace();
+   return (StorageHandle)desc;
+}
+
+StorageHandle PackedStorage::openForReading(PageID page, bool countAsAccess) {
+   int desc;
+   if ( (desc=(int)LegacyStorage::openForReading(page, false))!= -1 ) {
+      if (!seekTo(page, desc, false)) {
+         //this is not an error condition here, may and shall happen!
+         ::close(desc);
+      } else {
+         return (StorageHandle)desc;
+      }
+   }
+   return StorageHandle();
+}
+
+
+
+
+cTelePage::cTelePage(PageID t_page, uchar t_flags, uchar t_lang,int t_mag)
+  : mag(t_mag), flags(t_flags), lang(t_lang), page(t_page)
+{
+   memset(pagebuf,' ',26*40);
+}
+
+cTelePage::~cTelePage() {
+}
+
+void cTelePage::SetLine(int line, uchar *myptr)
+{
+   memcpy(pagebuf+40*line,myptr,40);
+}
+
+void cTelePage::save()
+{
+   Storage *s=Storage::instance();
+   unsigned char buf;
+   StorageHandle fd;
+   if ( (fd=s->openForWriting(page)) ) {
+      s->write("VTXV4",5,fd);
+      buf=0x01; s->write(&buf,1,fd);
+      buf=mag;  s->write(&buf,1,fd);
+      buf=page.page; s->write(&buf,1,fd);
+      buf=flags; s->write(&buf,1,fd);
+      buf=lang; s->write(&buf,1,fd);
+      buf=0x00; s->write(&buf,1,fd);
+      buf=0x00; s->write(&buf,1,fd);
+      s->write(pagebuf,24*40,fd);
+      s->close(fd);
+   }         
+}
+
+
+cTxtStatus::cTxtStatus(void)
+{
+   receiver = NULL;
+   currentLiveChannel = tChannelID::InvalidID;
+}
+
+cTxtStatus::~cTxtStatus()
+{
+    delete receiver;
+}
+
+void cTxtStatus::SetChannel(const cChannel *Channel)
+{
+   // ignore if channel is invalid (highly unlikely, this will ever
+   // be the case, but defensive coding rules!)
+   if (Channel == NULL) return;
+
+   // ignore if channel hasn't changed
+   if (currentLiveChannel == Channel->GetChannelID()) return;
+
+   // At this point it seems to be pretty sure to me, that the live
+   // channel was changed to a new channel and OSDTeletext can
+   // now re-attach the receiver to the new live channel
+
+   currentLiveChannel = Channel->GetChannelID();
+
+   delete receiver;
+   receiver = NULL;
+
+   int TPid = Channel->Tpid();
+
+   if (TPid) {
+      receiver = new cTxtReceiver(TPid, currentLiveChannel);
+      cDevice::ActualDevice()->AttachReceiver(receiver);
+   }
+}
+
+
+cTxtReceiver::cTxtReceiver(int TPid, tChannelID chan)
+ : cReceiver(chan, -1, TPid), cThread("osdteletext-receiver"),
+   chan(chan), TxtPage(0), buffer((188+60)*75), running(false)
+{
+   Storage::instance()->prepareDirectory(chan);
+   // 10 ms timeout on getting TS frames
+   buffer.SetTimeouts(0, 10);
+}
+
+
+cTxtReceiver::~cTxtReceiver()
+{
+   cReceiver::Detach();
+   if (running) {
+      running=false;
+      buffer.Signal();
+      Cancel(2);
+   }
+   buffer.Clear();
+   delete TxtPage;
+}
+
+void cTxtReceiver::Stop()
+{
+   Activate(false);
+}
+
+void cTxtReceiver::Activate(bool On)
+{
+  if (On) {
+     if (!running) {
+        running=true;
+        Start();
+        }
+     }
+  else if (running) {
+     running = false;
+     buffer.Signal();
+     Cancel(2);
+     }
+}
+
+void cTxtReceiver::Receive(uchar *Data, int Length)
+{
+   int len = Length+60;
+
+   if (!buffer.Check(len)) {
+      // Buffer overrun
+      buffer.Signal();
+      return;
+   }
+   cFrame *frame=new cFrame(Data, len);
+   if (frame && !buffer.Put(frame)) {
+      // Buffer overrun
+      delete frame;
+      buffer.Signal();
+   }
+}
+
+void cTxtReceiver::Action() {
+
+   while (running) {
+      cFrame *frame=buffer.Get();
+      if (frame) {
+         uchar *Datai=frame->Data();
+
+         for (int i=0; i < 4; i++) {
+            if (Datai[4+i*46]==2 || Datai[4+i*46]==3) {
+               for (int j=(8+i*46);j<(50+i*46);j++)
+                  Datai[j]=invtab[Datai[j]];
+               DecodeTXT(&Datai[i*46]);
+            }
+         }
+
+         buffer.Drop(frame);
+      } else
+         buffer.Wait();
+   }
+
+   buffer.Clear();
+   running=false;
+}
+
+uchar cTxtReceiver::unham16 (uchar *p)
+{
+  unsigned short c1,c2;
+  c1=unhamtab[p[0]];
+  c2=unhamtab[p[1]];
+  return (c1 & 0x0F) | (c2 & 0x0F) *16;
+}
+
+void cTxtReceiver::DecodeTXT(uchar* TXT_buf)
+{
+   // Format of buffer:
+   //   0x00-0x04  ?
+   //   0x05-0x06  Clock Run-In?
+   //   0x07       Framing Code?
+   //   0x08       Magazine number (100-digit of page number)
+   //   0x09       Line number
+   //   0x0A..0x31 Line data
+   // Line 0 only:
+   //   0x0A       10-digit of page number
+   //   0x0B       1-digit of page number
+   //   0x0C       Sub-Code bits 0..3
+   //   0x0D       Sub-Code bits 4..6 + C4 flag
+   //   0x0E       Sub-Code bits 8..11
+   //   0x0F       Sub-Code bits 12..13 + C5,C6 flag
+   //   0x10       C7-C10 flags
+   //   0x11       C11-C14 flags
+   //
+   // Flags:
+   //   C4 - Erase last page, new page transmitted
+   //   C5 - News flash, boxed display
+   //   C6 - Subtitle, boxed display
+   //   C7 - Suppress Header, dont show line 0
+   //   C8 - Update, page has changed
+   //   C9 - Interrupt Sequence, page number is out of order
+   //   C10 - Inhibit Display
+   //   C11 - Magazine Serial mode
+   //   C12-C14 - Language selection, lower 3 bits
+
+
+   int hdr,mag,mag8,line;
+   uchar *ptr;
+   uchar flags,lang;
+
+   hdr = unham16 (&TXT_buf[0x8]);
+   mag = hdr & 0x07;
+   mag8 = mag ?: 8;
+   line = (hdr>>3) & 0x1f;
+   ptr = &TXT_buf[10];
+
+   switch (line) {
+   case 0: 
+      {
+      unsigned char b1, b2, b3, b4;
+      int pgno, subno;
+      b1 = unham16 (ptr);    
+      // Page no, 10- and 1-digit
+
+      if (b1 == 0xff) break;
+      if (TxtPage) {
+         TxtPage->save();
+         delete TxtPage;
+         TxtPage=NULL;
+      }
+
+      b2 = unham16 (ptr+2); // Sub-code 0..6 + C4
+      b3 = unham16 (ptr+4); // Sub-code 8..13 + C5,C6
+      b4 = unham16 (ptr+6); // C7..C14
+
+      // flags:
+      //   0x80  C4 - Erase page
+      //   0x40  C5 - News flash
+      //   0x20  C6 - Subtitle
+      //   0x10  C7 - Suppress Header
+      //   0x08  C8 - Update
+      //   0x04  C9 - Interrupt Sequence
+      //   0x02  C9 (Bug?)
+      //   0x01  C11 - Magazine Serial mode
+      flags=b2 & 0x80;
+      flags|=(b3&0x40)|((b3>>2)&0x20); //??????
+      flags|=((b4<<4)&0x10)|((b4<<2)&0x08)|(b4&0x04)|((b4>>1)&0x02)|((b4>>4)&0x01);
+      lang=((b4>>5) & 0x07);
+
+      pgno = mag8 * 256 + b1;
+      subno = (b2 + b3 * 256) & 0x3f7f;         // Sub Page Number
+
+      TxtPage = new cTelePage(PageID(chan, pgno, subno), flags, lang, mag);
+      TxtPage->SetLine((int)line,(uchar *)ptr);
+      break;
+      }
+   case 1 ... 25: 
+      {
+      if (TxtPage) TxtPage->SetLine((int)line,(uchar *)ptr); 
+      break;
+      }
+   /*case 23: 
+      {
+      if (TxtPage) {
+         TxtPage->save();
+         delete TxtPage;
+         TxtPage=NULL;
+      }
+      break;
+      }*/
+   default:
+      break;
+   }
+}
+
+
diff -NaurwB streamdev/server/txtrecv.h streamdev2/server/txtrecv.h
--- streamdev/server/txtrecv.h	1970-01-01 01:00:00.000000000 +0100
+++ streamdev2/server/txtrecv.h	2009-07-07 07:52:54.000000000 +0200
@@ -0,0 +1,192 @@
+/***************************************************************************
+ *       Copyright (c) 2003,2004 by Marcel Wiesweg                         *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef __TXTRECV_H                   
+#define __TXTRECV_H
+
+#include <vdr/status.h>
+#include <vdr/receiver.h>
+#include <vdr/thread.h>
+#include <vdr/ringbuffer.h>
+
+#include <stdio.h>
+#include <unistd.h>
+
+struct PageID {
+   PageID() { page=subPage=0; }
+   PageID(tChannelID id, int p, int s) { set(id, p, s); }
+   void set(tChannelID id, int p, int s)
+      { channel=id; page=p; subPage=s; }
+   tChannelID channel;
+   int page;
+   int subPage;
+};
+
+struct StorageHandle {
+public:
+   StorageHandle() { handle=-1; }
+   StorageHandle(const StorageHandle &s) { handle=s.handle; }
+   StorageHandle(int h) { handle=h; }
+   StorageHandle &operator=(int h) { handle=h; return *this; }
+   StorageHandle &operator=(const StorageHandle &s) { handle=s.handle; return *this; }
+   operator bool() const { return handle!=-1; }
+   operator int() const { return handle; }
+private:
+   int handle;
+};
+
+class RootDir {
+public:
+   static void setRootDir(const char *);
+   static const char *getRootDir();
+protected:
+   static const char *root;
+};
+
+class Storage : public RootDir {
+public:
+   virtual ~Storage();
+   enum StorageSystem { StorageSystemLegacy, StorageSystemPacked };
+   //must be called before the first call to instance()
+   static void setSystem(StorageSystem system);
+   void setMaxStorage(int maxMB=-1);
+   
+   static Storage *instance();
+   
+   //must be called before operation starts. Set all options (RootDir, maxStorage) before.
+   void init();   
+   virtual void cleanUp() = 0;
+   
+   virtual void getFilename(char *buffer, int bufLength, PageID page);
+   void prepareDirectory(tChannelID chan);
+   
+   virtual StorageHandle openForWriting(PageID page) = 0;
+   virtual StorageHandle openForReading(PageID page, bool countAsAccess) = 0;
+   virtual ssize_t write(const void *ptr, size_t size, StorageHandle stream) = 0;
+   virtual ssize_t read(void *ptr, size_t size, StorageHandle stream) = 0;
+   virtual void close(StorageHandle stream) = 0;
+protected:
+   virtual void initMaxStorage(int maxMB=-1) = 0;
+   
+   Storage();
+   int cleanSubDir(const char *dir);
+   int doCleanUp();
+   virtual int actualFileSize(int netFileSize) { return netFileSize; }
+   static Storage *s_self;
+   void freeSpace();
+   bool exists(const char* file);
+   
+   long byteCount;
+   cString currentDir;
+private:
+   static StorageSystem system;
+   int storageOption;
+   bool failedFreeSpace;
+};
+
+class LegacyStorage : public Storage {
+public:
+   LegacyStorage();
+   virtual ~LegacyStorage();
+   virtual void cleanUp();
+   
+   virtual StorageHandle openForWriting(PageID page);
+   virtual StorageHandle openForReading(PageID page, bool countAsAccess);
+   virtual ssize_t write(const void *ptr, size_t size, StorageHandle stream);
+   virtual ssize_t read(void *ptr, size_t size, StorageHandle stream)
+     { return ::read((int)stream, ptr, size); }
+   virtual void close(StorageHandle stream)
+     { ::close((int)stream); }
+protected:
+   virtual void initMaxStorage(int maxMB=-1);
+   void registerFile(PageID page);
+   virtual int actualFileSize(int netFileSize);
+   //int maxPages;
+   long maxBytes;
+   int fsBlockSize;
+   int pageBytes;
+};
+
+class PackedStorage : public LegacyStorage {
+public:
+   PackedStorage();
+   //virtual void setMaxStorage(int maxMB=-1);
+   //virtual void cleanUp();
+   
+   virtual void getFilename(char *buffer, int bufLength, PageID page);
+   virtual StorageHandle openForWriting(PageID page);
+   virtual StorageHandle openForReading(PageID page, bool countAsAccess);
+protected:
+   struct PageAddress {
+      bool operator==(const PageID &id) const
+        { return page==id.page && subPage==id.subPage; }
+      void operator=(const PageID &id)
+        { page=id.page; subPage=id.subPage; }
+      int page;
+      int subPage;
+   };
+   bool seekTo(PageID page, int fd, bool create);
+   void registerFile(PageID page);
+};
+
+class cTelePage {
+ private:
+  int mag;
+  unsigned char flags;
+  unsigned char lang;
+  PageID page;
+  unsigned char pagebuf[27*40];
+  char Directory [255];
+ public:
+  cTelePage(PageID page, uchar flags, uchar lang, int mag);
+  ~cTelePage();
+  void SetLine(int, uchar*);
+  void save();
+ };
+
+class cRingTxtFrames : public cRingBufferFrame {
+ public:
+  cRingTxtFrames(int Size) : cRingBufferFrame(Size, true) {};
+  ~cRingTxtFrames() { Clear(); };
+  void Wait(void) { WaitForGet(); };
+  void Signal(void) { EnableGet(); };
+  bool Check(int Size) { return (Free() >= Size); };
+};
+
+class cTxtReceiver : public cReceiver, public cThread {
+private:
+   void DecodeTXT(uchar*);
+   uchar unham16 (uchar*);
+   tChannelID chan;
+   cTelePage *TxtPage;
+protected:
+   virtual void Activate(bool On);
+   virtual void Receive(uchar *Data, int Length);
+   void Action();
+   cRingTxtFrames buffer;
+   bool running;
+public:
+   cTxtReceiver(int TPid, tChannelID chan);
+   virtual ~cTxtReceiver();
+   virtual void Stop();
+};
+
+class cTxtStatus {
+private:
+   cTxtReceiver *receiver;
+   tChannelID currentLiveChannel;
+public:
+   cTxtStatus(void);
+   ~cTxtStatus();
+   void SetChannel(const cChannel *Channel);
+};
+
+
+#endif
diff -NaurwB streamdev/server/txttables.h streamdev2/server/txttables.h
--- streamdev/server/txttables.h	1970-01-01 01:00:00.000000000 +0100
+++ streamdev2/server/txttables.h	2009-07-03 14:26:22.000000000 +0200
@@ -0,0 +1,112 @@
+/* This file is copied from Ralph Metzler's vbidecode package. */
+
+/* 
+    tables.h - some data conversion tables for vbidecode
+*/
+
+#ifndef _TABLES_H
+#define _TABLES_H
+
+unsigned char invtab[256] = {
+  0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 
+  0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 
+  0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 
+  0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
+  0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 
+  0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
+  0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 
+  0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
+  0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 
+  0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
+  0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 
+  0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
+  0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 
+  0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
+  0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 
+  0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
+  0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 
+  0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
+  0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 
+  0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
+  0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 
+  0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
+  0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 
+  0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
+  0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 
+  0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
+  0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 
+  0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
+  0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 
+  0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
+  0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 
+  0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff, 
+};
+
+unsigned char unhamtab[256] = {
+  0x01, 0xff, 0x81, 0x01, 0xff, 0x00, 0x01, 0xff, 
+  0xff, 0x02, 0x01, 0xff, 0x0a, 0xff, 0xff, 0x07, 
+  0xff, 0x00, 0x01, 0xff, 0x00, 0x80, 0xff, 0x00, 
+  0x06, 0xff, 0xff, 0x0b, 0xff, 0x00, 0x03, 0xff, 
+  0xff, 0x0c, 0x01, 0xff, 0x04, 0xff, 0xff, 0x07, 
+  0x06, 0xff, 0xff, 0x07, 0xff, 0x07, 0x07, 0x87, 
+  0x06, 0xff, 0xff, 0x05, 0xff, 0x00, 0x0d, 0xff, 
+  0x86, 0x06, 0x06, 0xff, 0x06, 0xff, 0xff, 0x07, 
+  0xff, 0x02, 0x01, 0xff, 0x04, 0xff, 0xff, 0x09, 
+  0x02, 0x82, 0xff, 0x02, 0xff, 0x02, 0x03, 0xff, 
+  0x08, 0xff, 0xff, 0x05, 0xff, 0x00, 0x03, 0xff, 
+  0xff, 0x02, 0x03, 0xff, 0x03, 0xff, 0x83, 0x03, 
+  0x04, 0xff, 0xff, 0x05, 0x84, 0x04, 0x04, 0xff, 
+  0xff, 0x02, 0x0f, 0xff, 0x04, 0xff, 0xff, 0x07, 
+  0xff, 0x05, 0x05, 0x85, 0x04, 0xff, 0xff, 0x05, 
+  0x06, 0xff, 0xff, 0x05, 0xff, 0x0e, 0x03, 0xff, 
+  0xff, 0x0c, 0x01, 0xff, 0x0a, 0xff, 0xff, 0x09, 
+  0x0a, 0xff, 0xff, 0x0b, 0x8a, 0x0a, 0x0a, 0xff, 
+  0x08, 0xff, 0xff, 0x0b, 0xff, 0x00, 0x0d, 0xff, 
+  0xff, 0x0b, 0x0b, 0x8b, 0x0a, 0xff, 0xff, 0x0b, 
+  0x0c, 0x8c, 0xff, 0x0c, 0xff, 0x0c, 0x0d, 0xff, 
+  0xff, 0x0c, 0x0f, 0xff, 0x0a, 0xff, 0xff, 0x07, 
+  0xff, 0x0c, 0x0d, 0xff, 0x0d, 0xff, 0x8d, 0x0d, 
+  0x06, 0xff, 0xff, 0x0b, 0xff, 0x0e, 0x0d, 0xff, 
+  0x08, 0xff, 0xff, 0x09, 0xff, 0x09, 0x09, 0x89, 
+  0xff, 0x02, 0x0f, 0xff, 0x0a, 0xff, 0xff, 0x09, 
+  0x88, 0x08, 0x08, 0xff, 0x08, 0xff, 0xff, 0x09, 
+  0x08, 0xff, 0xff, 0x0b, 0xff, 0x0e, 0x03, 0xff, 
+  0xff, 0x0c, 0x0f, 0xff, 0x04, 0xff, 0xff, 0x09, 
+  0x0f, 0xff, 0x8f, 0x0f, 0xff, 0x0e, 0x0f, 0xff, 
+  0x08, 0xff, 0xff, 0x05, 0xff, 0x0e, 0x0d, 0xff, 
+  0xff, 0x0e, 0x0f, 0xff, 0x0e, 0x8e, 0xff, 0x0e, 
+};
+
+unsigned char cct2vtx_table[] = 
+  { 0x20, 0x21, 0x22, 0x23,
+    0x24, 0x25, 0x26, 0x27,
+    0x28, 0x29, 0x2a, 0x2b,
+    0x2c, 0x2d, 0x2e, 0x2f,
+
+    0x30, 0x31, 0x32, 0x33,
+    0x34, 0x35, 0x36, 0x37,
+    0x38, 0x39, 0x3a, 0x3b,
+    0x3c, 0x3d, 0x3e, 0xef,
+
+    0x40, 0x41, 0x42, 0x43,
+    0x44, 0x45, 0x46, 0x47,
+    0x48, 0x49, 0x4a, 0x4b,
+    0x4c, 0x4d, 0x4e, 0x4f,
+
+    0x50, 0x51, 0x52, 0x53,
+    0x54, 0x55, 0x56, 0x57,
+    0x58, 0x59, 0x5a, 0x5b,
+    0x5c, 0x5d, 0x5e, 0x5f,
+
+    0x60, 0x61, 0x62, 0x63,
+    0x64, 0x65, 0x66, 0x67,
+    0x68, 0x69, 0x6a, 0x6b,
+    0x6c, 0x6d, 0x6e, 0x6f,
+
+    0x70, 0x71, 0x72, 0x73,
+    0x74, 0x75, 0x76, 0x77,
+    0x78, 0x79, 0x7a, 0x7b,
+    0x7c, 0x7d, 0x7e, 0x7f
+  }; 
+
+#endif
diff -NaurwB streamdev/streamdev-server.c streamdev2/streamdev-server.c
--- streamdev/streamdev-server.c	2009-06-19 08:32:38.000000000 +0200
+++ streamdev2/streamdev-server.c	2009-07-07 09:26:01.000000000 +0200
@@ -12,6 +12,7 @@
 #include "server/setup.h"
 #include "server/server.h"
 #include "server/suspend.h"
+#include "server/txtrecv.h"
 
 #if !defined(APIVERSNUM) || APIVERSNUM < 10509
 #error "VDR-1.5.9 API version or greater is required!"
@@ -25,6 +26,7 @@
 
 cPluginStreamdevServer::~cPluginStreamdevServer() 
 {
+	Storage::instance()->cleanUp();
 	free(opt_auth);
 	free(opt_remux);
 }
@@ -40,6 +42,17 @@
 	return
 		"  -a <LOGIN:PASSWORD>, --auth=<LOGIN:PASSWORD>  Credentials for HTTP authentication.\n"
 		"  -r <CMD>, --remux=<CMD>  Define an external command for remuxing.\n"
+		"  -d        --directory=DIR    The directory where the temporary\n"
+		"                               teletext files will be stored.\n"
+		"                               (default: /var/cache/vdr/vtx)\n"
+		"  -n        --max-cache=NUM    Maximum size in megabytes of cache used\n"
+		"                               to store the teletext pages on the harddisk.\n"
+		"                               (default: a calculated value below 50 MB)\n"
+		"  -s        --cache-system=SYS Set the teletext cache system to be used.\n"
+		"                               Choose \"legacy\" for the traditional\n"
+		"                               one-file-per-page system.\n"
+		"                               Default is \"packed\" for the \n"
+		"                               one-file-for-a-few-pages system.\n";
 		;
 }
 
@@ -49,11 +62,15 @@
 	static const struct option long_options[] = {
 		{ "auth", required_argument, NULL, 'a' },
 		{ "remux", required_argument, NULL, 'r' },
+		{ "directory", required_argument, NULL, 'd' },
+		{ "max-cache", required_argument, NULL, 'n' },
+		{ "cache-system", required_argument, NULL, 's' },
 		{ NULL, 0, NULL, 0 }
 	};
 
+	int maxStorage=-1;
 	int c;
-	while((c = getopt_long(argc, argv, "a:r:", long_options, NULL)) != -1) {
+	while((c = getopt_long(argc, argv, "a:r:s:d:n:", long_options, NULL)) != -1) {
 		switch (c) {
 			case 'a':
 				{
@@ -71,10 +88,30 @@
 				    free(opt_remux);
 				opt_remux = strdup(optarg);
 				break;
+			case 's':
+				if (!optarg)
+					break;
+				if (strcasecmp(optarg, "legacy")==0)
+					Storage::setSystem(Storage::StorageSystemLegacy);
+				else if (strcasecmp(optarg, "packed")==0)
+					Storage::setSystem(Storage::StorageSystemPacked);
+				break;
+			case 'd':
+				Storage::setRootDir(optarg);
+				break;
+			case 'n': if (isnumber(optarg)) {
+					int n = atoi(optarg);
+					maxStorage=n;
+				}
+				break;
 			default:
 				return false;
 		}
 	}
+	//do this here because the option -s to change the storage system might be given
+	// after -n, and then -s would have no effect
+	if (maxStorage>=0)
+		Storage::instance()->setMaxStorage(maxStorage);
 	return true;
 }
 
