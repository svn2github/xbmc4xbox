diff -NaurwB streamdev/common.h streamdev2/common.h
--- streamdev/common.h	2009-06-19 08:32:38.000000000 +0200
+++ streamdev2/common.h	2009-06-24 00:26:10.000000000 +0200
@@ -72,6 +72,7 @@
 	siLive,
 	siReplay,
 	siLiveFilter,
+	siDataRespond,
 	si_Count
 };
 
diff -NaurwB streamdev/Makefile streamdev2/Makefile
--- streamdev/Makefile	2009-06-19 08:32:38.000000000 +0200
+++ streamdev2/Makefile	2009-06-24 00:26:10.000000000 +0200
@@ -61,7 +61,7 @@
 	server/componentVTP.o server/componentHTTP.o server/componentIGMP.o \
 	server/connectionVTP.o server/connectionHTTP.o server/connectionIGMP.o \
 	server/streamer.o server/livestreamer.o server/livefilter.o \
-	server/suspend.o server/setup.o server/menuHTTP.o \
+	server/suspend.o server/setup.o server/menuHTTP.o server/recplayer.o \
 	remux/tsremux.o remux/ts2pes.o remux/ts2ps.o remux/ts2es.o remux/extern.o
 	
 ifdef DEBUG
diff -NaurwB streamdev/server/connectionVTP.h streamdev2/server/connectionVTP.h
--- streamdev/server/connectionVTP.h	2008-07-16 08:00:48.000000000 +0200
+++ streamdev2/server/connectionVTP.h	2009-06-24 00:26:10.000000000 +0200
@@ -2,6 +2,7 @@
 #define VDR_STREAMDEV_SERVERS_CONNECTIONVTP_H
 
 #include "server/connection.h"
+#include "server/recplayer.h"
 
 class cTBSocket;
 class cStreamdevLiveStreamer;
@@ -9,6 +10,7 @@
 class cLSTEHandler;
 class cLSTCHandler;
 class cLSTTHandler;
+class cLSTRHandler;
 
 class cConnectionVTP: public cServerConnection {
 	friend class cLSTEHandler;
@@ -21,16 +23,19 @@
 	cStreamdevLiveStreamer   *m_LiveStreamer;
 	cTBSocket                *m_FilterSocket;
 	cStreamdevFilterStreamer *m_FilterStreamer;
+	cTBSocket                *m_RecSocket;
+	cTBSocket                *m_DataSocket;
 
 	char                   *m_LastCommand;
 	eStreamType             m_StreamType;
 	bool                    m_FiltersSupport;
+	RecPlayer              *m_RecPlayer;
 
 	// Members adopted for SVDRP
-	cRecordings Recordings;
 	cLSTEHandler *m_LSTEHandler;
 	cLSTCHandler *m_LSTCHandler;
 	cLSTTHandler *m_LSTTHandler;
+	cLSTRHandler *m_LSTRHandler;
 
 protected:
 	template<class cHandler>
@@ -51,7 +56,9 @@
 	bool CmdCAPS(char *Opts);
 	bool CmdPROV(char *Opts);
 	bool CmdPORT(char *Opts);
+	bool CmdREAD(char *Opts);
 	bool CmdTUNE(char *Opts);
+	bool CmdPLAY(char *Opts);
 	bool CmdADDP(char *Opts);
 	bool CmdDELP(char *Opts);
 	bool CmdADDF(char *Opts);
@@ -64,14 +71,20 @@
 	bool CmdLSTE(char *Opts);
 	bool CmdLSTC(char *Opts);
 	bool CmdLSTT(char *Opts);
+	bool CmdLSTR(char *Opts);
 
 	// Commands adopted from SVDRP
+	bool CmdSTAT(const char *Option);
 	bool CmdMODT(const char *Option);
 	bool CmdNEWT(const char *Option);
 	bool CmdDELT(const char *Option);
-
-	//bool CmdLSTR(char *Opts);
-	//bool CmdDELR(char *Opts);
+	bool CmdNEXT(const char *Option);
+	bool CmdNEWC(const char *Option);
+	bool CmdMODC(const char *Option);
+	bool CmdMOVC(const char *Option);
+	bool CmdDELC(const char *Option);
+	bool CmdDELR(const char *Option);
+	bool CmdRENR(const char *Option);
 
 	bool Respond(int Code, const char *Message, ...)
 			__attribute__ ((format (printf, 3, 4)));
diff -NaurwB streamdev/server/recplayer.c streamdev2/server/recplayer.c
--- streamdev/server/recplayer.c	1970-01-01 01:00:00.000000000 +0100
+++ streamdev2/server/recplayer.c	2009-06-24 00:26:10.000000000 +0200
@@ -0,0 +1,288 @@
+/*
+    Copyright 2004-2005 Chris Tallon
+
+    This file is part of VOMP.
+    and adopted for streamdev to play recordings
+
+    VOMP is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    VOMP is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with VOMP; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#include "recplayer.h"
+
+#define _XOPEN_SOURCE 600
+#include <fcntl.h>
+
+RecPlayer::RecPlayer(cRecording* rec)
+{
+  file = NULL;
+  fileOpen = 0;
+  lastPosition = 0;
+  recording = rec;
+  for(int i = 1; i < 1000; i++) segments[i] = NULL;
+
+  // FIXME find out max file path / name lengths
+
+#if VDRVERSNUM >= 10703
+  indexFile = new cIndexFile(recording->FileName(), false, rec->IsPesRecording());
+#else
+  indexFile = new cIndexFile(recording->FileName(), false);
+#endif
+  if (!indexFile) esyslog("ERROR: Streamdev: Failed to create indexfile!");
+
+  scan();
+}
+
+void RecPlayer::scan()
+{
+  if (file) fclose(file);
+  totalLength = 0;
+  fileOpen = 0;
+  totalFrames = 0;
+
+  int i = 1;
+  while(segments[i++]) delete segments[i];
+
+  char fileName[2048];
+  for(i = 1; i < 1000; i++)
+  {
+
+#if APIVERSNUM < 10703
+    snprintf(fileName, 2047, "%s/%03i.vdr", recording->FileName(), i);
+    //log->log("RecPlayer", Log::DEBUG, "FILENAME: %s", fileName);
+    file = fopen(fileName, "r");
+#else
+    snprintf(fileName, 2047, "%s/%05i.ts", recording->FileName(), i);
+    file = fopen(fileName, "r");
+    if (!file) {
+      snprintf(fileName, 2047, "%s/%03i.vdr", recording->FileName(), i);
+      file = fopen(fileName, "r");
+    }
+#endif
+    if (!file) break;
+
+    segments[i] = new Segment();
+    segments[i]->start = totalLength;
+    fseek(file, 0, SEEK_END);
+    totalLength += ftell(file);
+    totalFrames = indexFile->Last();
+    //log->log("RecPlayer", Log::DEBUG, "File %i found, totalLength now %llu, numFrames = %lu", i, totalLength, totalFrames);
+    segments[i]->end = totalLength;
+    fclose(file);
+  }
+
+  file = NULL;
+}
+
+RecPlayer::~RecPlayer()
+{
+  //log->log("RecPlayer", Log::DEBUG, "destructor");
+  int i = 1;
+  while(segments[i++]) delete segments[i];
+  if (file) fclose(file);
+}
+
+int RecPlayer::openFile(int index)
+{
+  if (file) fclose(file);
+
+  char fileName[2048];
+
+#if APIVERSNUM >= 10703
+  snprintf(fileName, 2047, "%s/%05i.ts", recording->FileName(), index);
+  isyslog("openFile called for index %i string:%s", index, fileName);
+
+  file = fopen(fileName, "r");
+  if (file)
+  {
+    fileOpen = index;
+    return 1;
+  }
+#endif
+
+  snprintf(fileName, 2047, "%s/%03i.vdr", recording->FileName(), index);
+  isyslog("openFile called for index %i string:%s", index, fileName);
+  //log->log("RecPlayer", Log::DEBUG, "openFile called for index %i string:%s", index, fileName);
+
+  file = fopen(fileName, "r");
+  if (file)
+  {
+    fileOpen = index;
+    return 1;
+  }
+
+  //log->log("RecPlayer", Log::DEBUG, "file failed to open");
+  fileOpen = 0;
+  return 0;
+}
+
+uint64_t RecPlayer::getLengthBytes()
+{
+  return totalLength;
+}
+
+uint32_t RecPlayer::getLengthFrames()
+{
+  return totalFrames;
+}
+
+unsigned long RecPlayer::getBlock(unsigned char* buffer, uint64_t position, unsigned long amount)
+{
+  if ((amount > totalLength) || (amount > 500000))
+  {
+    //log->log("RecPlayer", Log::DEBUG, "Amount %lu requested and rejected", amount);
+    return 0;
+  }
+
+  if (position >= totalLength)
+  {
+    //log->log("RecPlayer", Log::DEBUG, "Client asked for data starting past end of recording!");
+    return 0;
+  }
+
+  if ((position + amount) > totalLength)
+  {
+    //log->log("RecPlayer", Log::DEBUG, "Client asked for some data past the end of recording, adjusting amount");
+    amount = totalLength - position;
+  }
+
+  // work out what block position is in
+  int segmentNumber;
+  for(segmentNumber = 1; segmentNumber < 1000; segmentNumber++)
+  {
+    if ((position >= segments[segmentNumber]->start) && (position < segments[segmentNumber]->end)) break;
+    // position is in this block
+  }
+
+  // we could be seeking around
+  if (segmentNumber != fileOpen)
+  {
+    if (!openFile(segmentNumber)) return 0;
+  }
+
+  uint64_t currentPosition = position;
+  uint32_t yetToGet = amount;
+  uint32_t got = 0;
+  uint32_t getFromThisSegment = 0;
+  uint32_t filePosition;
+
+  while(got < amount)
+  {
+    if (got)
+    {
+      // if(got) then we have already got some and we are back around
+      // advance the file pointer to the next file
+      if (!openFile(++segmentNumber)) return 0;
+    }
+
+    // is the request completely in this block?
+    if ((currentPosition + yetToGet) <= segments[segmentNumber]->end)
+      getFromThisSegment = yetToGet;
+    else
+      getFromThisSegment = segments[segmentNumber]->end - currentPosition;
+
+    filePosition = currentPosition - segments[segmentNumber]->start;
+    fseek(file, filePosition, SEEK_SET);
+    if (fread(&buffer[got], getFromThisSegment, 1, file) != 1) return 0; // umm, big problem.
+
+    // Tell linux not to bother keeping the data in the FS cache
+    posix_fadvise(file->_fileno, filePosition, getFromThisSegment, POSIX_FADV_DONTNEED);
+
+    got += getFromThisSegment;
+    currentPosition += getFromThisSegment;
+    yetToGet -= getFromThisSegment;
+  }
+
+  lastPosition = position;
+  return got;
+}
+
+uint64_t RecPlayer::getLastPosition()
+{
+  return lastPosition;
+}
+
+cRecording* RecPlayer::getCurrentRecording()
+{
+  return recording;
+}
+
+uint64_t RecPlayer::positionFromFrameNumber(uint32_t frameNumber)
+{
+  if (!indexFile) return 0;
+
+#if VDRVERSNUM >= 10703
+  uint16_t retFileNumber;
+  off_t retFileOffset;
+#else
+  uchar retFileNumber;
+  int retFileOffset;
+#endif
+
+  if (!indexFile->Get((int)frameNumber, &retFileNumber, &retFileOffset))
+  {
+    return 0;
+  }
+
+//  log->log("RecPlayer", Log::DEBUG, "FN: %u FO: %i", retFileNumber, retFileOffset);
+  if (!segments[retFileNumber]) return 0;
+  uint64_t position = segments[retFileNumber]->start + retFileOffset;
+//  log->log("RecPlayer", Log::DEBUG, "Pos: %llu", position);
+
+  return position;
+}
+
+uint32_t RecPlayer::frameNumberFromPosition(uint64_t position)
+{
+  if (!indexFile) return 0;
+
+  if (position >= totalLength)
+  {
+    //log->log("RecPlayer", Log::DEBUG, "Client asked for data starting past end of recording!");
+    return 0;
+  }
+
+  uint8_t segmentNumber;
+  for(segmentNumber = 1; segmentNumber < 255; segmentNumber++)
+  {
+    if ((position >= segments[segmentNumber]->start) && (position < segments[segmentNumber]->end)) break;
+    // position is in this block
+  }
+  uint32_t askposition = position - segments[segmentNumber]->start;
+  return indexFile->Get((int)segmentNumber, askposition);
+
+}
+
+
+bool RecPlayer::getNextIFrame(uint32_t frameNumber, uint32_t direction, uint64_t* rfilePosition, uint32_t* rframeNumber, uint32_t* rframeLength)
+{
+  // 0 = backwards
+  // 1 = forwards
+
+  if (!indexFile) return false;
+
+  int iframeLength;
+  int indexReturnFrameNumber;
+
+  indexReturnFrameNumber = (uint32_t)indexFile->GetNextIFrame(frameNumber, (direction==1 ? true : false), NULL, NULL, &iframeLength);
+  //log->log("RecPlayer", Log::DEBUG, "GNIF input framenumber:%lu, direction=%lu, output:framenumber=%i, framelength=%i", frameNumber, direction, indexReturnFrameNumber, iframeLength);
+
+  if (indexReturnFrameNumber == -1) return false;
+
+  *rfilePosition = positionFromFrameNumber(indexReturnFrameNumber);
+  *rframeNumber = (uint32_t)indexReturnFrameNumber;
+  *rframeLength = (uint32_t)iframeLength;
+
+  return true;
+}
diff -NaurwB streamdev/server/recplayer.h streamdev2/server/recplayer.h
--- streamdev/server/recplayer.h	1970-01-01 01:00:00.000000000 +0100
+++ streamdev2/server/recplayer.h	2009-06-24 00:26:10.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+    Copyright 2004-2005 Chris Tallon
+
+    This file is part of VOMP.
+
+    VOMP is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    VOMP is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with VOMP; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+*/
+
+#ifndef RECPLAYER_H
+#define RECPLAYER_H
+
+#include <stdio.h>
+#include <vdr/recording.h>
+
+#include "server/streamer.h"
+
+class Segment
+{
+  public:
+    uint64_t start;
+    uint64_t end;
+};
+
+class RecPlayer
+{
+  public:
+    RecPlayer(cRecording* rec);
+    ~RecPlayer();
+    uint64_t getLengthBytes();
+    uint32_t getLengthFrames();
+    unsigned long getBlock(unsigned char* buffer, uint64_t position, unsigned long amount);
+    int openFile(int index);
+    uint64_t getLastPosition();
+    cRecording* getCurrentRecording();
+    void scan();
+    uint64_t positionFromFrameNumber(uint32_t frameNumber);
+    uint32_t frameNumberFromPosition(uint64_t position);
+    bool getNextIFrame(uint32_t frameNumber, uint32_t direction, uint64_t* rfilePosition, uint32_t* rframeNumber, uint32_t* rframeLength);
+
+  private:
+    cRecording* recording;
+    cIndexFile* indexFile;
+    FILE* file;
+    int fileOpen;
+    Segment* segments[1000];
+    uint64_t totalLength;
+    uint64_t lastPosition;
+    uint32_t totalFrames;
+};
+
+#endif
diff -NaurwB streamdev/server/connectionVTP.c streamdev2/server/connectionVTP.c
--- streamdev/server/connectionVTP.c	2009-06-19 08:32:45.000000000 +0200
+++ streamdev2/server/connectionVTP.c	2009-06-24 19:38:17.000000000 +0200
@@ -8,6 +8,8 @@
 #include "setup.h"
 
 #include <vdr/tools.h>
+#include <vdr/videodir.h>
+#include <vdr/menu.h>
 #include <tools/select.h>
 #include <string.h>
 #include <ctype.h>
@@ -28,13 +30,20 @@
 	563: Recording not available (currently?)
 */
 
+enum eDumpModeStreamdev { dmsdAll, dmsdPresent, dmsdFollowing, dmsdAtTime, dmsdFromToTime };
+
 // --- cLSTEHandler -----------------------------------------------------------
 
 class cLSTEHandler 
 {
 private:
+#ifdef USE_PARENTALRATING
+	enum eStates { Channel, Event, Title, Subtitle, Description, Vps, Content,
+	               EndEvent, EndChannel, EndEPG };
+#else
 	enum eStates { Channel, Event, Title, Subtitle, Description, Vps, 
 	               EndEvent, EndChannel, EndEPG };
+#endif /* PARENTALRATING */
 	cConnectionVTP    *m_Client;
 	cSchedulesLock    *m_SchedulesLock;
 	const cSchedules  *m_Schedules;
@@ -44,6 +53,7 @@
 	char              *m_Error;
 	eStates            m_State;
 	bool               m_Traverse;
+	time_t             m_ToTime;
 public:
 	cLSTEHandler(cConnectionVTP *Client, const char *Option);
 	~cLSTEHandler();
@@ -59,10 +69,12 @@
 		m_Errno(0),
 		m_Error(NULL),
 		m_State(Channel),
-		m_Traverse(false)
+		m_Traverse(false),
+		m_ToTime(0)
 {
-	eDumpMode dumpmode = dmAll;
+  eDumpModeStreamdev dumpmode = dmsdAll;
 	time_t attime = 0;
+	time_t fromtime = 0;
 
 	if (m_Schedules != NULL && *Option) {
 		char buf[strlen(Option) + 1];
@@ -70,13 +82,13 @@
 		const char *delim = " \t";
 		char *strtok_next;
 		char *p = strtok_r(buf, delim, &strtok_next);
-		while (p && dumpmode == dmAll) {
+		while (p && dumpmode == dmsdAll) {
 			if (strcasecmp(p, "NOW") == 0)
-				dumpmode = dmPresent;
+				dumpmode = dmsdPresent;
 			else if (strcasecmp(p, "NEXT") == 0)
-				dumpmode = dmFollowing;
+				dumpmode = dmsdFollowing;
 			else if (strcasecmp(p, "AT") == 0) {
-				dumpmode = dmAtTime;
+				dumpmode = dmsdAtTime;
 				if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
 					if (isnumber(p))
 						attime = strtol(p, NULL, 10);
@@ -90,6 +102,39 @@
 					m_Error = strdup("Missing time");
 					break;
 				}
+			}
+			else if (strcasecmp(p, "FROM") == 0) {
+				dumpmode = dmsdFromToTime;
+				if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
+					if (isnumber(p))
+						fromtime = strtol(p, NULL, 10);
+					else {
+						m_Errno = 501;
+						m_Error = strdup("Invalid time");
+						break;
+					}
+					if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
+					  if (strcasecmp(p, "TO") == 0) {
+					    if ((p = strtok_r(NULL, delim, &strtok_next)) != NULL) {
+                if (isnumber(p))
+                  m_ToTime = strtol(p, NULL, 10);
+                else {
+                  m_Errno = 501;
+                  m_Error = strdup("Invalid time");
+                  break;
+                }
+              } else {
+                m_Errno = 501;
+                m_Error = strdup("Missing time");
+                break;
+              }
+					  }
+					}
+				} else {
+					m_Errno = 501;
+					m_Error = strdup("Missing time");
+					break;
+				}
 			} else if (!m_Schedule) {
 				cChannel* Channel = NULL;
 				if (isnumber(p))
@@ -129,16 +174,29 @@
 
 		if (m_Schedule != NULL && m_Schedule->Events() != NULL) {
 			switch (dumpmode) {
-			case dmAll:       m_Event = m_Schedule->Events()->First();
+			case dmsdAll:       m_Event = m_Schedule->Events()->First();
 							  m_Traverse = true;
 							  break;
-			case dmPresent:   m_Event = m_Schedule->GetPresentEvent();
+			case dmsdPresent:   m_Event = m_Schedule->GetPresentEvent();
 							  break;
-			case dmFollowing: m_Event = m_Schedule->GetFollowingEvent();
+			case dmsdFollowing: m_Event = m_Schedule->GetFollowingEvent();
 							  break;
-			case dmAtTime:    m_Event = m_Schedule->GetEventAround(attime);
+			case dmsdAtTime:    m_Event = m_Schedule->GetEventAround(attime);
+							  break;
+			case dmsdFromToTime:
+                if (m_Schedule->Events()->Count() <= 1) {
+                  m_Event = m_Schedule->Events()->First();
+                  break;
+                }
+			          if (fromtime < m_Schedule->Events()->First()->StartTime()) {
+			            fromtime = m_Schedule->Events()->First()->StartTime();
+			          }
+                if (m_ToTime > m_Schedule->Events()->Last()->EndTime()) {
+                  m_ToTime = m_Schedule->Events()->Last()->EndTime();
+                }
+			          m_Event = m_Schedule->GetEventAround(fromtime);
+			          m_Traverse = true;
 							  break;
-
 			}
 		}
 	}
@@ -227,7 +285,11 @@
 		break;
 
 	case Vps:
+#ifdef USE_PARENTALRATING
+		m_State = Content;
+#else
 		m_State = EndEvent;
+#endif /* PARENTALRATING */
 		if (m_Event->Vps())
 #ifdef __FreeBSD__
 			return m_Client->Respond(-215, "V %d", m_Event->Vps());
@@ -238,9 +300,26 @@
 			return Next(Last);
 		break;
 
+#ifdef USE_PARENTALRATING
+  case Content:
+    m_State = EndEvent;
+    if (!isempty(m_Event->GetContentsString())) {
+      char *copy = strdup(m_Event->GetContentsString());
+      cString cpy(copy, true);
+      strreplace(copy, '\n', '|');
+      return m_Client->Respond(-215, "G %i %i %s", m_Event->Contents() & 0xF0, m_Event->Contents() & 0x0F, copy);
+    } else
+      return Next(Last);
+    break;
+#endif
+
 	case EndEvent:
-		if (m_Traverse)
+		if (m_Traverse) {
 			m_Event = m_Schedule->Events()->Next(m_Event);
+			if ((m_Event != NULL) && (m_ToTime != 0) && (m_Event->StartTime() > m_ToTime)) {
+			  m_Event = NULL;
+			}
+		}
 		else
 			m_Event = NULL;
 
@@ -377,7 +456,7 @@
 			}
 		}
 
-		if (i < Channels.MaxNumber())
+		if (i < Channels.MaxNumber() + 1)
 			Last = false;
 	}
 
@@ -468,6 +547,186 @@
 	return result;
 }
 
+// --- cLSTRHandler -----------------------------------------------------------
+
+class cLSTRHandler 
+{
+private:
+	enum eStates { Recording, Event, Title, Subtitle, Description, Components, Vps, 
+	               EndRecording };
+	cConnectionVTP *m_Client;
+	cRecording     *m_Recording;
+	const cEvent   *m_Event;
+	int             m_Index;
+	int             m_Errno;
+	char           *m_Error;
+	bool            m_Traverse;
+	bool            m_Info;
+	eStates         m_State;
+	int             m_CurrentComponent;
+public:
+	cLSTRHandler(cConnectionVTP *Client, const char *Option);
+	~cLSTRHandler();
+	bool Next(bool &Last);
+};
+
+cLSTRHandler::cLSTRHandler(cConnectionVTP *Client, const char *Option):
+		m_Client(Client),
+		m_Recording(NULL),
+		m_Event(NULL),
+		m_Index(0),
+		m_Errno(0),
+		m_CurrentComponent(0),
+		m_Error(NULL),
+		m_Traverse(false),
+		m_Info(false),
+		m_State(Recording)
+{
+  bool recordings = Recordings.Update(true);
+	if (*Option) {
+		if (isnumber(Option)) {
+		  m_Recording = Recordings.Get(strtol(Option, NULL, 10) - 1);
+#if defined(USE_STREAMDEVEXT) || APIVERSNUM >= 10705
+		  m_Event = m_Recording->Info()->GetEvent();
+#endif
+		  m_Info = true;
+			if (m_Recording == NULL) {
+				m_Errno = 501;
+				asprintf(&m_Error, "Recording \"%s\" not found", Option);
+			}
+		}
+		else {
+			m_Errno = 501;
+			asprintf(&m_Error, "Error in Recording number \"%s\"", Option);
+		}
+	} 
+	else if (Recordings.Count()) {
+		m_Traverse = true;
+		m_Index = 0;
+		m_Recording = Recordings.Get(m_Index);
+		if (m_Recording == NULL) {
+			m_Errno = 501;
+			asprintf(&m_Error, "Recording \"%d\" not found", m_Index + 1);
+		}
+	} 
+	else {
+		m_Errno = 550;
+		m_Error = strdup("No recordings available");
+	}
+}
+
+cLSTRHandler::~cLSTRHandler()
+{
+	if (m_Error != NULL)
+		free(m_Error);
+}
+
+bool cLSTRHandler::Next(bool &Last)
+{
+	if (m_Error != NULL) {
+		Last = true;
+		cString str(m_Error, true);
+		m_Error = NULL;
+		return m_Client->Respond(m_Errno, *str);
+	}
+	
+	if (m_Info) {
+	  Last = false;
+		switch (m_State) {
+    case Recording:
+      if (m_Recording != NULL) {
+        m_State = Event;
+        return m_Client->Respond(-215, "C %s%s%s", 
+                                *m_Recording->Info()->ChannelID().ToString(), 
+                                 m_Recording->Info()->ChannelName() ? " " : "", 
+                                 m_Recording->Info()->ChannelName() ? m_Recording->Info()->ChannelName() : "");
+      } 
+      else {
+        m_State = EndRecording;
+        return Next(Last);
+      }
+      break;
+    
+    case Event:
+      m_State = Title;
+      if (m_Event != NULL) {
+        return m_Client->Respond(-215, "E %u %ld %d %X", (unsigned int) m_Event->EventID(), 
+                                                         m_Event->StartTime(), m_Event->Duration(), 
+                                                         m_Event->TableID(), m_Event->Version());
+      } 
+      return Next(Last);
+    
+    case Title:
+      m_State = Subtitle;
+      return m_Client->Respond(-215, "T %s", m_Recording->Info()->Title());
+
+    case Subtitle:
+      m_State = Description;
+      if (!isempty(m_Recording->Info()->ShortText())) {
+        return m_Client->Respond(-215, "S %s", m_Recording->Info()->ShortText());
+      }
+      return Next(Last);
+
+    case Description:
+      m_State = Components;
+      if (!isempty(m_Recording->Info()->Description())) {
+        m_State = Components;
+        char *copy = strdup(m_Recording->Info()->Description());
+        cString cpy(copy, true);
+        strreplace(copy, '\n', '|');
+        return m_Client->Respond(-215, "D %s", copy);
+      }
+      return Next(Last);
+
+    case Components:
+		  if (m_Recording->Info()->Components()) {
+		    if (m_CurrentComponent < m_Recording->Info()->Components()->NumComponents())
+		    {
+		      tComponent *p = m_Recording->Info()->Components()->Component(m_CurrentComponent);
+		      m_CurrentComponent++;
+		      if (!Setup.UseDolbyDigital && p->stream == 0x02 && p->type == 0x05)
+            return Next(Last);
+          
+          return m_Client->Respond(-215, "X %s", *p->ToString());
+		    }
+		  }
+      m_State = Vps;
+      return Next(Last);
+    
+    case Vps:
+      m_State = EndRecording;
+      if (m_Event != NULL) {
+        if (m_Event->Vps())
+        {
+          return m_Client->Respond(-215, "V %ld", m_Event->Vps());
+        }
+      }
+      return Next(Last);
+
+    case EndRecording:
+      Last = true;
+      return m_Client->Respond(215, "End of recording information");
+    }
+	}
+	else
+	{
+    bool result;
+    char *buffer;
+    Last = !m_Traverse || m_Index >= Recordings.Count() - 1;
+    result = m_Client->Respond(Last ? 250 : -250, "%d %s", m_Recording->Index() + 1, m_Recording->Title(' ', true));
+
+    if (m_Traverse && !Last) {
+      m_Recording = Recordings.Get(++m_Index);
+      if (m_Recording == NULL) {
+        m_Errno = 501;
+        asprintf(&m_Error, "Recording \"%d\" not found", m_Index + 1);
+      }
+    }
+    return result;
+	}
+	return false;
+}
+
 // --- cConnectionVTP ---------------------------------------------------------
 
 cConnectionVTP::cConnectionVTP(void): 
@@ -476,12 +735,16 @@
 		m_LiveStreamer(NULL),
 		m_FilterSocket(NULL),
 		m_FilterStreamer(NULL),
+		m_RecSocket(NULL),
+		m_DataSocket(NULL),
 		m_LastCommand(NULL),
 		m_StreamType(stTSPIDS),
 		m_FiltersSupport(false),
+		m_RecPlayer(NULL),
 		m_LSTEHandler(NULL),
 		m_LSTCHandler(NULL),
-		m_LSTTHandler(NULL)
+		m_LSTTHandler(NULL),
+		m_LSTRHandler(NULL)
 {
 }
 
@@ -491,11 +754,15 @@
 		free(m_LastCommand);
 	delete m_LiveStreamer;
 	delete m_LiveSocket;
+	delete m_RecSocket;
 	delete m_FilterStreamer;
 	delete m_FilterSocket;
+	delete m_DataSocket;
 	delete m_LSTTHandler;
 	delete m_LSTCHandler;
 	delete m_LSTEHandler;
+	delete m_LSTRHandler;
+	delete m_RecPlayer;
 }
 
 inline bool cConnectionVTP::Abort(void) const
@@ -548,7 +815,7 @@
 	}
 	
 	if      (strcasecmp(Cmd, "LSTE") == 0) return CmdLSTE(param);
-	//else if (strcasecmp(Cmd, "LSTR") == 0) return CmdLSTR(param);
+	else if (strcasecmp(Cmd, "LSTR") == 0) return CmdLSTR(param);
 	else if (strcasecmp(Cmd, "LSTT") == 0) return CmdLSTT(param);
 	else if (strcasecmp(Cmd, "LSTC") == 0) return CmdLSTC(param);
 
@@ -561,7 +828,9 @@
 	if      (strcasecmp(Cmd, "CAPS") == 0) return CmdCAPS(param);
 	else if (strcasecmp(Cmd, "PROV") == 0) return CmdPROV(param);
 	else if (strcasecmp(Cmd, "PORT") == 0) return CmdPORT(param);
+	else if (strcasecmp(Cmd, "READ") == 0) return CmdREAD(param);
 	else if (strcasecmp(Cmd, "TUNE") == 0) return CmdTUNE(param);
+	else if (strcasecmp(Cmd, "PLAY") == 0) return CmdPLAY(param);
 	else if (strcasecmp(Cmd, "ADDP") == 0) return CmdADDP(param);
 	else if (strcasecmp(Cmd, "DELP") == 0) return CmdDELP(param);
 	else if (strcasecmp(Cmd, "ADDF") == 0) return CmdADDF(param);
@@ -570,10 +839,17 @@
 	else if (strcasecmp(Cmd, "QUIT") == 0) return CmdQUIT();
 	else if (strcasecmp(Cmd, "SUSP") == 0) return CmdSUSP();
 	// Commands adopted from SVDRP
-	//else if (strcasecmp(Cmd, "DELR") == 0) return CmdDELR(param);
+	else if (strcasecmp(Cmd, "STAT") == 0) return CmdSTAT(param);
 	else if (strcasecmp(Cmd, "MODT") == 0) return CmdMODT(param);
 	else if (strcasecmp(Cmd, "NEWT") == 0) return CmdNEWT(param);
 	else if (strcasecmp(Cmd, "DELT") == 0) return CmdDELT(param);
+	else if (strcasecmp(Cmd, "NEXT") == 0) return CmdNEXT(param);
+	else if (strcasecmp(Cmd, "NEWC") == 0) return CmdNEWC(param);
+	else if (strcasecmp(Cmd, "MODC") == 0) return CmdMODC(param);
+	else if (strcasecmp(Cmd, "MOVC") == 0) return CmdMOVC(param);
+	else if (strcasecmp(Cmd, "DELC") == 0) return CmdDELC(param);
+	else if (strcasecmp(Cmd, "DELR") == 0) return CmdDELR(param);
+	else if (strcasecmp(Cmd, "RENR") == 0) return CmdRENR(param);
 	else
 		return Respond(500, "Unknown Command \"%s\"", Cmd);
 }
@@ -646,7 +922,7 @@
 	if (ep == Opts || !isspace(*ep))
 		return Respond(500, "Use: PORT Id Destination");
 	
-	if (id != siLive && id != siLiveFilter)
+	if (id != siLive && id != siLiveFilter && id != siReplay && id != siDataRespond)
 		return Respond(501, "Wrong connection id %d", id);
 	
 	Opts = skipspace(ep);
@@ -696,6 +972,7 @@
 		return Respond(220, "Port command ok, data connection opened");
 	}
 
+  if (id == siLive) {
 	if(m_LiveSocket && m_LiveStreamer)
 		m_LiveStreamer->Stop();
 	delete m_LiveSocket;
@@ -716,6 +993,71 @@
 	return Respond(220, "Port command ok, data connection opened");
 }
 
+  if (id == siReplay) {
+      delete m_RecSocket;
+
+      m_RecSocket = new cTBSocket(SOCK_STREAM);
+      if (!m_RecSocket->Connect(dataip, dataport)) {
+          esyslog("ERROR: Streamdev: Couldn't open data connection to %s:%d: %s",
+                  dataip, dataport, strerror(errno));
+          DELETENULL(m_RecSocket);
+          return Respond(551, "Couldn't open data connection");
+      }
+
+      if (!m_RecSocket->SetDSCP())
+          LOG_ERROR_STR("unable to set DSCP sockopt");
+
+      return Respond(220, "Port command ok, data connection opened");
+  }
+
+  if (id == siDataRespond) {
+      delete m_DataSocket;
+
+      m_DataSocket = new cTBSocket(SOCK_STREAM);
+      if (!m_DataSocket->Connect(dataip, dataport)) {
+          esyslog("ERROR: Streamdev: Couldn't open data connection to %s:%d: %s",
+                  dataip, dataport, strerror(errno));
+          DELETENULL(m_DataSocket);
+          return Respond(551, "Couldn't open data connection");
+      }
+
+      if (!m_DataSocket->SetDSCP())
+          LOG_ERROR_STR("unable to set DSCP sockopt");
+
+      return Respond(220, "Port command ok, data connection opened");
+  }
+  return Respond(551, "Couldn't open data connection");
+}
+
+bool cConnectionVTP::CmdREAD(char *Opts)
+{
+    if (*Opts) {
+        char *tail;
+        uint64_t position = strtoll(Opts, &tail, 10);
+        if (tail && tail != Opts) {
+            tail = skipspace(tail);
+            if (tail && tail != Opts) {
+                int size = strtol(tail, NULL, 10);
+                uint8_t* data = (uint8_t*)malloc(size+4);
+                unsigned long count_readed = m_RecPlayer->getBlock(data, position, size);
+                unsigned long count_written = m_RecSocket->SysWrite(data, count_readed);
+
+                free(data);
+                return Respond(220, "%lu Bytes submitted", count_written);
+            }
+            else {
+                return Respond(501, "Missing position");
+            }
+        }
+        else {
+            return Respond(501, "Missing size");
+        }
+    }
+    else {
+        return Respond(501, "Missing position");
+    }
+}
+
 bool cConnectionVTP::CmdTUNE(char *Opts) 
 {
 	const cChannel *chan;
@@ -747,6 +1089,32 @@
 	return Respond(220, "Channel tuned");
 }
 
+bool cConnectionVTP::CmdPLAY(char *Opts)
+{
+    Recordings.Update(true);
+    if (*Opts) {
+        if (isnumber(Opts)) {
+            cRecording *recording = Recordings.Get(strtol(Opts, NULL, 10) - 1);
+            if (recording) {
+                if (m_RecPlayer) {
+                    delete m_RecPlayer;
+                }
+                m_RecPlayer = new RecPlayer(recording);
+                return Respond(220, "%llu (Bytes), %u (Frames)", (long long unsigned int) m_RecPlayer->getLengthBytes(), (unsigned int) m_RecPlayer->getLengthFrames());
+            }
+            else {
+                return Respond(550, "Recording \"%s\" not found", Opts);
+            }
+          }
+        else {
+            return Respond(500, "Use: PLAY record");
+        }
+    }
+    else {
+        return Respond(500, "Use: PLAY record");
+    }
+}
+
 bool cConnectionVTP::CmdADDP(char *Opts) 
 {
 	int pid;
@@ -842,6 +1210,13 @@
 		DELETENULL(m_FilterStreamer);
 		DELETENULL(m_FilterSocket);
 		break;
+	case siReplay:
+		DELETENULL(m_RecPlayer);
+		DELETENULL(m_RecSocket);
+		break;
+	case siDataRespond:
+		DELETENULL(m_DataSocket);
+		break;
 	default:
 		return Respond(501, "Wrong connection id %d", id);
 		break;
@@ -879,7 +1254,8 @@
 		Handler = new cHandler(this, Option);
 	}
 
-	bool last, result = false;
+	bool last = false;
+	bool result = false;
 	if (Handler != NULL)
 		result = Handler->Next(last);
 	else
@@ -905,11 +1281,66 @@
 	return CmdLSTX(m_LSTTHandler, Option);
 }
 
+bool cConnectionVTP::CmdLSTR(char *Option)
+{
+	return CmdLSTX(m_LSTRHandler, Option);
+}
+
 // Functions adopted from SVDRP
 #define INIT_WRAPPER() bool _res
 #define Reply(c,m...) _res = Respond(c,m)
 #define EXIT_WRAPPER() return _res
 
+bool cConnectionVTP::CmdSTAT(const char *Option)
+{
+    INIT_WRAPPER();
+    if (*Option) {
+        if (strcasecmp(Option, "DISK") == 0) {
+            int FreeMB, UsedMB;
+            int Percent = VideoDiskSpace(&FreeMB, &UsedMB);
+            Reply(250, "%dMB %dMB %d%%", FreeMB + UsedMB, FreeMB, Percent);
+        }
+        else if (strcasecmp(Option, "NAME") == 0) {
+            Reply(250, "vdr - The Video Disk Recorder with Streamdev-Server");
+        }
+        else if (strcasecmp(Option, "VERSION") == 0) {
+            Reply(250, "VDR: %s | Streamdev: %s", VDRVERSION, VERSION);
+        }
+        else if (strcasecmp(Option, "RECORDS") == 0) {
+            bool recordings = Recordings.Load();
+            Recordings.Sort();
+            if (recordings) {
+                cRecording *recording = Recordings.Last();
+                Reply(250, "%d", recording->Index() + 1);
+            }
+            else {
+                Reply(250, "0");
+            }
+        }
+        else if (strcasecmp(Option, "CHANNELS") == 0) {
+            Reply(250, "%d", Channels.MaxNumber());
+        }
+        else if (strcasecmp(Option, "TIMERS") == 0) {
+            Reply(250, "%d", Timers.Count());
+        }
+        else if (strcasecmp(Option, "CHARSET") == 0) {
+            Reply(250, "%s", cCharSetConv::SystemCharacterTable());
+        }
+        else if (strcasecmp(Option, "TIME") == 0) {
+            time_t timeNow = time(NULL);
+            struct tm* timeStruct = localtime(&timeNow);
+            int timeOffset = timeStruct->tm_gmtoff;
+
+            Reply(250, "%u %i", timeNow, timeOffset);
+        }
+        else
+            Reply(501, "Invalid Option \"%s\"", Option);
+    }
+    else
+    Reply(501, "No option given");
+    EXIT_WRAPPER();
+}
+
 bool cConnectionVTP::CmdMODT(const char *Option)
 {
 	INIT_WRAPPER();
@@ -990,52 +1421,236 @@
 	EXIT_WRAPPER();
 }
 
-/*bool cConnectionVTP::CmdLSTR(char *Option) {
+bool cConnectionVTP::CmdNEXT(const char *Option)
+{
+	INIT_WRAPPER();
+    cTimer *t = Timers.GetNextActiveTimer();
+    if (t) {
+        time_t Start = t->StartTime();
+        int Number = t->Index() + 1;
+        if (!*Option)
+            Reply(250, "%d %s", Number, *TimeToString(Start));
+        else if (strcasecmp(Option, "ABS") == 0)
+            Reply(250, "%d %ld", Number, Start);
+        else if (strcasecmp(Option, "REL") == 0)
+            Reply(250, "%d %ld", Number, Start - time(NULL));
+        else
+            Reply(501, "Unknown option: \"%s\"", Option);
+    }
+    else
+        Reply(550, "No active timers");
+    EXIT_WRAPPER();
+}
+
+bool cConnectionVTP::CmdNEWC(const char *Option)
+{
+    INIT_WRAPPER();
+    if (*Option) {
+        cChannel ch;
+        if (ch.Parse(Option)) {
+            if (Channels.HasUniqueChannelID(&ch)) {
+                cChannel *channel = new cChannel;
+                *channel = ch;
+                Channels.Add(channel);
+                Channels.ReNumber();
+                Channels.SetModified(true);
+                isyslog("new channel %d %s", channel->Number(), *channel->ToText());
+                Reply(250, "%d %s", channel->Number(), *channel->ToText());
+            }
+            else {
+                Reply(501, "Channel settings are not unique");
+            }
+        }
+        else {
+            Reply(501, "Error in channel settings");
+        }
+    }
+    else {
+        Reply(501, "Missing channel settings");
+    }
+    EXIT_WRAPPER();
+}
+
+bool cConnectionVTP::CmdMODC(const char *Option)
+{
+    INIT_WRAPPER();
+    if (*Option) {
+        char *tail;
+        int n = strtol(Option, &tail, 10);
+        if (tail && tail != Option) {
+            tail = skipspace(tail);
+            if (!Channels.BeingEdited()) {
+                cChannel *channel = Channels.GetByNumber(n);
+                if (channel) {
+                    cChannel ch;
+                    if (ch.Parse(tail)) {
+                        if (Channels.HasUniqueChannelID(&ch, channel)) {
+                            *channel = ch;
+                            Channels.ReNumber();
+                            Channels.SetModified(true);
+                            isyslog("modifed channel %d %s", channel->Number(), *channel->ToText());
+                            Reply(250, "%d %s", channel->Number(), *channel->ToText());
+                        }
+                        else {
+                            Reply(501, "Channel settings are not unique");
+                        }
+                    }
+                    else {
+                        Reply(501, "Error in channel settings");
+                    }
+                }
+                else {
+                    Reply(501, "Channel \"%d\" not defined", n);
+                }
+            }
+            else {
+                Reply(550, "Channels are being edited - try again later");
+            }
+        }
+        else {
+            Reply(501, "Error in channel number");
+        }
+    }
+    else {
+        Reply(501, "Missing channel settings");
+    }
+    EXIT_WRAPPER();
+}
+
+bool cConnectionVTP::CmdMOVC(const char *Option)
+{
+    INIT_WRAPPER();
+    if (*Option) {
+        if (!Channels.BeingEdited() && !Timers.BeingEdited()) {
+            char *tail;
+            int From = strtol(Option, &tail, 10);
+            if (tail && tail != Option) {
+                tail = skipspace(tail);
+                if (tail && tail != Option) {
+                    int To = strtol(tail, NULL, 10);
+                    int CurrentChannelNr = cDevice::CurrentChannel();
+                    cChannel *CurrentChannel = Channels.GetByNumber(CurrentChannelNr);
+                    cChannel *FromChannel = Channels.GetByNumber(From);
+                    if (FromChannel) {
+                        cChannel *ToChannel = Channels.GetByNumber(To);
+                        if (ToChannel) {
+                            int FromNumber = FromChannel->Number();
+                            int ToNumber = ToChannel->Number();
+                            if (FromNumber != ToNumber) {
+                                Channels.Move(FromChannel, ToChannel);
+                                Channels.ReNumber();
+                                Channels.SetModified(true);
+                                if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
+                                    if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring()) {
+                                        Channels.SwitchTo(CurrentChannel->Number());
+                                    }
+                                    else {
+                                        cDevice::SetCurrentChannel(CurrentChannel);
+                                    }
+                                }
+                               isyslog("channel %d moved to %d", FromNumber, ToNumber);
+                               Reply(250,"Channel \"%d\" moved to \"%d\"", From, To);
+                            }
+                            else {
+                                Reply(501, "Can't move channel to same postion");
+                            }
+                        }
+                        else {
+                            Reply(501, "Channel \"%d\" not defined", To);
+                        }
+                    }
+                    else {
+                        Reply(501, "Channel \"%d\" not defined", From);
+                    }
+                }
+                else {
+                    Reply(501, "Error in channel number");
+                }
+            }
+            else {
+                Reply(501, "Error in channel number");
+            }
+        }
+        else {
+            Reply(550, "Channels or timers are being edited - try again later");
+        }
+    }
+    else {
+        Reply(501, "Missing channel number");
+    }
+    EXIT_WRAPPER();
+}
+
+bool cConnectionVTP::CmdDELC(const char *Option)
+{
 	INIT_WRAPPER();
-  bool recordings = Recordings.Load();
-	Recordings.Sort();
   if (*Option) {
      if (isnumber(Option)) {
-        cRecording *recording = Recordings.Get(strtol(Option, NULL, 10) - 1);
-        if (recording) {
-           if (recording->Summary()) {
-              char *summary = strdup(recording->Summary());
-              Reply(250, "%s", strreplace(summary,'\n','|'));
-              free(summary);
+        if (!Channels.BeingEdited()) {
+           cChannel *channel = Channels.GetByNumber(strtol(Option, NULL, 10));
+           if (channel) {
+              for (cTimer *timer = Timers.First(); timer; timer = Timers.Next(timer)) {
+                  if (timer->Channel() == channel) {
+                     Reply(550, "Channel \"%s\" is in use by timer %d", Option, timer->Index() + 1);
+                     return false;
               }
+              }
+              int CurrentChannelNr = cDevice::CurrentChannel();
+              cChannel *CurrentChannel = Channels.GetByNumber(CurrentChannelNr);
+              if (CurrentChannel && channel == CurrentChannel) {
+                 int n = Channels.GetNextNormal(CurrentChannel->Index());
+                 if (n < 0)
+                    n = Channels.GetPrevNormal(CurrentChannel->Index());
+                 CurrentChannel = Channels.Get(n);
+                 CurrentChannelNr = 0; // triggers channel switch below
+                 }
+              Channels.Del(channel);
+              Channels.ReNumber();
+              Channels.SetModified(true);
+              isyslog("channel %s deleted", Option);
+              if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
+                 if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
+                    Channels.SwitchTo(CurrentChannel->Number());
            else
-              Reply(550, "No summary availabe");
+                    cDevice::SetCurrentChannel(CurrentChannel);
+                 }
+              Reply(250, "Channel \"%s\" deleted", Option);
            }
         else
-           Reply(550, "Recording \"%s\" not found", Option);
+              Reply(501, "Channel \"%s\" not defined", Option);
         }
      else
-        Reply(501, "Error in recording number \"%s\"", Option);
+           Reply(550, "Channels are being edited - try again later");
      }
-  else if (recordings) {
-     cRecording *recording = Recordings.First();
-     while (recording) {
-           Reply(recording == Recordings.Last() ? 250 : -250, "%d %s", recording->Index() + 1, recording->Title(' ', true));
-           recording = Recordings.Next(recording);
+     else
+        Reply(501, "Error in channel number \"%s\"", Option);
            }
+    else {
+        Reply(501, "Missing channel number");
      }
-  else
-     Reply(550, "No recordings available");
 	EXIT_WRAPPER();
 }
 
-bool cConnectionVTP::CmdDELR(char *Option) {
+bool cConnectionVTP::CmdDELR(const char *Option)
+{
 	INIT_WRAPPER();
   if (*Option) {
      if (isnumber(Option)) {
         cRecording *recording = Recordings.Get(strtol(Option, NULL, 10) - 1);
         if (recording) {
-           if (recording->Delete())
+                cRecordControl *rc = cRecordControls::GetRecordControl(recording->FileName());
+                if (!rc) {
+                    if (recording->Delete()) {
               Reply(250, "Recording \"%s\" deleted", Option);
+                        ::Recordings.DelByName(recording->FileName());
+                    }
            else
               Reply(554, "Error while deleting recording!");
            }
         else
+                    Reply(550, "Recording \"%s\" is in use by timer %d", Option, rc->Timer()->Index() + 1);
+            }
+            else
            Reply(550, "Recording \"%s\" not found%s", Option, Recordings.Count() ? "" : " (use LSTR before deleting)");
         }
      else
@@ -1044,7 +1659,55 @@
   else
      Reply(501, "Missing recording number");
 	EXIT_WRAPPER();
-}*/
+}
+
+bool cConnectionVTP::CmdRENR(const char *Option)
+{
+    INIT_WRAPPER();
+#if defined(USE_LIEMIKUUTIO) || defined(USE_LIEMIEXT)
+    bool recordings = Recordings.Update(true);
+    if (recordings) {
+        if (*Option) {
+            char *tail;
+            int n = strtol(Option, &tail, 10);
+            cRecording *recording = Recordings.Get(n - 1);
+            if (recording && tail && tail != Option) {
+#if APIVERSNUM < 10704
+                int priority = recording->priority;
+                int lifetime = recording->lifetime;
+#endif
+                char *oldName = strdup(recording->Name());
+                tail = skipspace(tail);
+#if APIVERSNUM < 10704
+                if (recording->Rename(tail, &priority, &lifetime)) {
+#else
+                if (recording->Rename(tail)) {
+#endif
+                    Reply(250, "Renamed \"%s\" to \"%s\"", oldName, recording->Name());
+                    Recordings.ChangeState();
+                    Recordings.TouchUpdate();
+                }
+                else {
+                    Reply(501, "Renaming \"%s\" to \"%s\" failed", oldName, tail);
+                }
+                free(oldName);
+            }
+            else {
+                Reply(501, "Recording not found or wrong syntax");
+            }
+        }
+        else {
+            Reply(501, "Missing Input settings");
+        }
+    }
+    else {
+        Reply(550, "No recordings available");
+    }
+#else
+    Reply(501, "Rename not supported, please use LIEMIEXT");
+#endif /* LIEMIKUUTIO */
+    EXIT_WRAPPER();
+}
 
 bool cConnectionVTP::Respond(int Code, const char *Message, ...)
 {
