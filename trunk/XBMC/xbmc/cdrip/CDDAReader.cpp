#include "stdafx.h"
#include "CDDAReader.h"
#include "../utils/log.h"

#define SECTOR_COUNT 55

CCDDAReader::CCDDAReader()
{
	m_sRipBuffer[0].pbtStream = NULL;
	m_sRipBuffer[1].pbtStream = NULL;

	m_iCurrentBuffer = 0;

	m_hReadEvent = CreateEvent(NULL, false, false, "rip read event");
	m_hDataReadyEvent = CreateEvent(NULL, false, false, "rip dataready event");
	m_hStopEvent = CreateEvent(NULL, false, false, "rip stop event");

	m_pCdIo = NULL;

	m_lsnStart = 0;
	m_lsnEnd = 0;
	m_lsnCurrent = 0;
}

CCDDAReader::~CCDDAReader()
{
	m_bStop = true;
	PulseEvent(m_hStopEvent);
	StopThread();

	CloseHandle(m_hReadEvent);
	CloseHandle(m_hDataReadyEvent);
	CloseHandle(m_hStopEvent);

	if (m_sRipBuffer[0].pbtStream) delete []m_sRipBuffer[0].pbtStream;
	if (m_sRipBuffer[1].pbtStream) delete []m_sRipBuffer[1].pbtStream;
}

bool CCDDAReader::Init(int iTrack)
{
	m_pCdIo=cdio_open_win32("D:");

	// Open the Ripper session
	if (!m_pCdIo)
	{
		CLog::Log(LOGERROR, "Error: Opening DVD-Drive failed");
		return false;
	}

	// Get Sart and end of the track to rip
	m_lsnStart = cdio_get_track_lsn(m_pCdIo, iTrack);
	m_lsnEnd = cdio_get_track_last_lsn(m_pCdIo, iTrack);
	m_lsnCurrent = m_lsnStart;

	CLog::Log(LOGINFO, "Track %d, Sectors %d", iTrack,	m_lsnEnd - m_lsnStart);

	// allocate 2 buffers
	// read around 128k per chunk. This makes the cd reading less noisy.
	m_sRipBuffer[0].pbtStream = new BYTE[CDIO_CD_FRAMESIZE_RAW*SECTOR_COUNT];
	m_sRipBuffer[1].pbtStream = new BYTE[CDIO_CD_FRAMESIZE_RAW*SECTOR_COUNT];

	Create();

	return true;
}

bool CCDDAReader::DeInit()
{
	m_bStop = true;
	SetEvent(m_hStopEvent);
	StopThread();

	m_iCurrentBuffer = 0;

	// free buffers
	if (m_sRipBuffer[0].pbtStream) delete []m_sRipBuffer[0].pbtStream;
	m_sRipBuffer[0].pbtStream = NULL;
	if (m_sRipBuffer[1].pbtStream) delete []m_sRipBuffer[1].pbtStream;
	m_sRipBuffer[1].pbtStream = NULL;

	// Close the Ripper session
	if (m_pCdIo)
	{
		cdio_destroy(m_pCdIo);
		m_pCdIo=NULL;
	}

	return true;
}

int CCDDAReader::GetPercent()
{
	return ((m_lsnCurrent-m_lsnStart)*100)/(m_lsnEnd-m_lsnStart);
}

int CCDDAReader::ReadChunk()
{
	// Are there enough sectors left to rip a fill chunk
	int iSectorCount=SECTOR_COUNT;
	while (m_lsnCurrent+iSectorCount>m_lsnEnd && iSectorCount>1)
		iSectorCount--;

	// Read data
	if (cdio_read_audio_sectors(m_pCdIo, m_sRipBuffer[m_iCurrentBuffer].pbtStream, m_lsnCurrent, iSectorCount)!=DRIVER_OP_SUCCESS)
	{
		m_sRipBuffer[m_iCurrentBuffer].lBytesRead=0;
		CLog::Log(LOGERROR, "Reading %d sectors of audio data starting at lsn %d failed", iSectorCount, m_lsnCurrent);
		return CDDARIP_ERR;
	}

	m_sRipBuffer[m_iCurrentBuffer].lBytesRead=CDIO_CD_FRAMESIZE_RAW*iSectorCount;
	m_lsnCurrent+=iSectorCount;

	if (m_lsnCurrent == m_lsnEnd) return CDDARIP_DONE; 

	return CDDARIP_OK;
}

void CCDDAReader::Process()
{
	// fill first buffer
	m_iCurrentBuffer = 0;
	HANDLE hHandles[2] = { m_hReadEvent, m_hStopEvent };

	m_sRipBuffer[0].iRipError = ReadChunk();
	SetEvent(m_hDataReadyEvent);
	
	while (!m_bStop)
	{
		// wait until someone called GetData()
		if (WaitForMultipleObjects(2, hHandles, false, INFINITE) == WAIT_OBJECT_0)
		{
			// event generated by m_hReadEvent, continue
			// switch buffer and start reading in this one
			m_iCurrentBuffer = m_iCurrentBuffer ? 0 : 1;
			m_sRipBuffer[m_iCurrentBuffer].iRipError = ReadChunk();

			SetEvent(m_hDataReadyEvent);
		}
	}
}

int CCDDAReader::GetData(BYTE** stream, long& lBytes)
{
	// wait until we are sure we have a buffer that is filled
	WaitForSingleObject(m_hDataReadyEvent, INFINITE);

	int iError = m_sRipBuffer[m_iCurrentBuffer].iRipError;
	*stream = m_sRipBuffer[m_iCurrentBuffer].pbtStream;
	lBytes = m_sRipBuffer[m_iCurrentBuffer].lBytesRead;

	// got data buffer, signal thread so it can start filling the other buffer
	SetEvent(m_hReadEvent);
	return iError;
}
